http://www.bimant.com/docs/glsl-es/abs/ >> (222ms) --> 
GLSL abs函数文档函数描述float abs(float x);该函数接收一个参数x，并返回它的绝对值。如果x为负数，则返回其相反数。如果x为正数，则返回x本身。参数x: 需要取绝对值的数值。可以是任何可实现类型。返回值返回值为x的绝对值。示例float a = abs(-5.0);// a = 5.0float b = abs(3.0);// b = 3.0注意事项如果x是一个整数，则计算时会自动将其转换为float类型。
----------
http://www.bimant.com/docs/glsl-es/acos/ >> (89ms) --> 
GLSL acos() 函数acos() 函数返回一个角度值，代表反余弦值。语法float acos(float x);参数x：必需。要计算反余弦值的角度值，取值范围为 [-1, 1]。返回值计算出反余弦值的角度值，取值范围为 [0, pi]。描述acos() 函数是数学库中的标准三角函数，它返回的是反余弦值。该函数的参数 x 必须在取值范围 [-1, 1] 内，否则函数将返回 NaN。如果角度值是正数，则返回值在 [0, pi/2] 内。如果角度值是负数，则返回值在 [pi/2, pi] 内。如果角度值为0，则返回值为 pi/2。需要注意的是，输入的参数 x 可能存在精度误差，这可能会影响 acos() 函数的计算结果。示例float x = 0.5;float angle = acos(x); // 等价于 angle = cos(angle)// 将角度值转换为弧度值float pi = 3.14159265359;float radian = angle * pi / 180.0;// 使用弧度值计算余弦值float cosine = cos(radian);版本OpenGL ES 2.0、3.0，OpenGL 2.0、3.0。
----------
http://www.bimant.com/docs/glsl-es/acosh/ >> (71ms) --> 
GLSL acosh函数函数描述float acosh(float x)acosh函数返回一个参数的反双曲余弦函数。参数x - 一个浮点数，指定要计算反双曲余弦函数的数值。返回值返回类型为float，表示参数的反双曲余弦函数的值。如果x小于1，则返回NaN。示例float acoshValue = acosh(2.0);上述示例中，acoshValue的值将会是1.317。注意事项acosh函数只能用于GLSL 1.30及以上版本，因为这个函数是在OpenGL 3.0中引入的。如果x小于1，则函数将返回NaN。在GLSL中，反双曲余弦函数可以通过以下公式进行计算：acosh(x) = ln(x + sqrt(x^2 - 1))
----------
http://www.bimant.com/docs/glsl-es/all/ >> (88ms) --> 
GLSL all()函数文档概述all()函数是一种逻辑函数，用于测试给定的布尔向量中的所有元素是否均为true。 如果所有元素都为true，则函数返回true；否则，返回false。语法bool all(bvec2 x);bool all(bvec3 x);bool all(bvec4 x);参数：x：布尔向量返回值：如果向量中的所有元素都为true，则返回true；否则返回false。示例以下是一个简单的GLSL代码示例，展示了如何使用all()函数。vec3 lightPosition = vec3(0.0, 1.0, 0.0);vec3 surfacePosition = vec3(0.0, 0.0, 0.0);vec3 surfaceNormal = vec3(0.0, 1.0, 0.0);bool shadowExists = texture(shadowMap, shadowCoord).r < shadowCoord.z;// 判断表达式是否为trueif (all(bvec2(shadowExists, surfaceNormal.y > 0.0))) { vec3 lightDirection = normalize(lightPosition - surfacePosition); float diffuse = max(dot(surfaceNormal, lightDirection), 0.0); color = vec4(diffuse * surfaceColor.rgb, surfaceColor.a);} else { color = vec4(surfaceColor.rgb * 0.1, surfaceColor.a);}在上面的示例中，all()函数用于判断变量shadowExists和表达式surfaceNormal.y > 0.0是否均为true。如果这两个条件都为true，则将计算光与表面之间的漫反射着色。否则，将表面颜色减少到原来的10％。
----------
http://www.bimant.com/docs/glsl-es/any/ >> (78ms) --> 
GLSL any()函数文档描述any()函数用于判断给定的布尔类型的变量中是否有任意一个为true。如果至少有一个为true，则该函数返回true，否则返回false。语法bool any(bvec2 x);bool any(bvec3 x);bool any(bvec4 x);参数x：一个bvec2、bvec3或bvec4类型的布尔类型向量。返回值true：如果给定向量中至少有一个元素为truefalse：如果给定向量中全部元素为false示例bvec3 testvec = bvec3(true, false, true);bool result = any(testvec); // result 为 truebvec4 testvec = bvec4(false, false, false, false);bool result = any(testvec); // result 为 false注意事项此函数仅适用于布尔类型向量（bvec2、bvec3和bvec4）。当传递给函数的向量为空时，结果为false。可以与其他操作符（如&&和||）一起使用，以构建更复杂的布尔逻辑。
----------
http://www.bimant.com/docs/glsl-es/asin/ >> (77ms) --> 
GLSL asin()函数函数描述GLSL的asin()函数返回弧度制下的反正弦值。函数原型float asin(float x);参数x：待求反正弦值的数值，范围必须在 [-1, 1] 内。返回值返回反正弦值，单位为弧度。示例vec2 uv = gl_FragCoord.xy / resolution.xy;float x = uv.x * 2.0 - 1.0; // 把纹理坐标转化为 [-1, 1] 之间的数值float y = uv.y * 2.0 - 1.0; // 把纹理坐标转化为 [-1, 1] 之间的数值float angle = asin(y); // 计算角度，单位为弧度gl_FragColor = vec4(vec3(angle / 3.1415926, 1.0), 1.0); // 把角度转化为颜色值注意事项参数范围必须在 [-1, 1] 内，否则会报错误；返回值单位为弧度，需要转化为度数或者其他角度单位，才能被业务逻辑所使用。
----------
http://www.bimant.com/docs/glsl-es/asinh/ >> (97ms) --> 
GLSL asinh()函数文档1. 简介asinh() 函数将输入数值转换成双曲正弦反函数的值。其定义为：$asinh(x) = ln(x + sqrt(x^2 + 1))$。2. 函数原型float asinh(float x)3. 参数x：输入值，类型为 float。4. 返回值函数返回参数 x 的双曲正弦反函数的值。5. 注意事项参数 x 的取值范围为 $[-inf, +inf]$。函数返回的值的取值范围为 $[-inf, +inf]$。当 x 的绝对值很小时， $asinh(x)$ 的值很接近于 $x$。当 x 的绝对值很大时，$asinh(x)$ 的值将接近于 $ln(2 * abs(x))$。6. 示例float a = asinh(2.0); // 1.4436355float b = asinh(0.0); // 0.0float c = asinh(-3.0); // -1.81844657. 参考资料GLSL 4.60 Specification - Math Functions
----------
http://www.bimant.com/docs/glsl-es/atan/ >> (58ms) --> 
GLSL atan函数函数定义float atan(float y_over_x)函数描述atan() 函数返回 y_over_x 的反正切值，返回的值范围在 -pi/2 到 pi/2 之间。输入参数y_over_x：要计算反正切的浮点数。返回值函数返回 y_over_x 的反正切值。返回值的单位为弧度。示例vec2 point = vec2(1.0, 1.0);float angle = atan(point.y / point.x);在上面的示例中，我们计算了 (1, 1) 点相对于原点的极角。注意事项atan() 函数对所有输入值均有效。atan() 函数可用于计算点与原点之间的极角。
----------



http://www.bimant.com/docs/glsl-es/atanh/ >> (60ms) --> 
GLSL的atanh函数函数原型：float atanh(float x);返回值：返回x的反双曲正切值。操作的值必须落在[-1,1]的范围内，否则返回NaN。参数x：要计算反双曲正切值的浮点数。返回值返回指定数字的反双曲正切值。注意事项操作的值必须落在[-1,1]的范围内，否则返回NaN。如果x为NaN，则返回NaN。反双曲正切函数atanh(x)的值可以表示为ln((1 + x) / (1 - x)) / 2。atan(x)是求反正切的函数，而atanh(x)是求反双曲正切的函数，两者不同。与其他三角函数一样，反双曲正切函数的运算结果通常需要进行弧度制或角度制转换。
----------
http://www.bimant.com/docs/glsl-es/ceil/ >> (80ms) --> 
GLSL Ceil 函数文档简介ceil() 函数在 GLSL（OpenGL Shading Language）中是一个内置函数，该函数返回给定数字的最小整数，使得该整数大于或等于给定数字。语法ceil(x)参数x：要进行操作的数值，类型为 float 或 vec（矢量）。返回值ceil() 函数返回 x 的最小整数。如果 x 是小数，则返回与 x 最接近的大于或等于 x 的祖先整数。示例float a = 3.14;float b = ceil(a); // 4.0vec2 v1 = vec2(1.2, 2.7);vec2 v2 = ceil(v1); // vec2(2.0, 3.0)注意事项x 的类型必须是 float 或 vec。如果 x 为负数，则返回的值将是在 x 较小舍入后的负数整数。例如，ceil(-2.4) 将返回 -2.0 而不是 -3.0。对于整数值，ceil() 函数返回值与原始输入值相同。ceil() 函数对于计算机图形学和计算机游戏中的很多场景都非常有用。例如，可以将其用于计算向上取整的纹理坐标，或取整光线跟踪中的交点位置等等。
----------
http://www.bimant.com/docs/glsl-es/clamp/ >> (86ms) --> 
GLSL Clamp函数GLSL的clamp函数用于限制一个值的范围在指定的最小值和最大值之间。该函数返回一个限制后的值。函数原型：float clamp(float x, float minVal, float maxVal)vec2 clamp(vec2 x, vec2 minVal, vec2 maxVal)vec3 clamp(vec3 x, vec3 minVal, vec3 maxVal)vec4 clamp(vec4 x, vec4 minVal, vec4 maxVal)参数说明：x：需要限制范围的值。minVal：限制范围的最小值。maxVal：限制范围的最大值。返回值：一个值，它是将参数x限制在最小值minVal和最大值maxVal之间后得到的结果。示例：以下是一个示例，它使用clamp函数将矢量的每个分量限制在0和1之间：vec3 v = vec3(1.2, -0.5, 2.0);vec3 clampedV = clamp(v, vec3(0.0), vec3(1.0));在这个例子中，向量v的每个分量都被限制在0和1之间。因此，得到的限制后的值为(1.0, 0.0, 1.0)。注意事项：clamp函数不会修改参数x的值，它只是返回一个限制后的值。最小值minVal必须小于或等于最大值maxVal。可以使用clamp函数来实现其他函数，例如阈值函数或线性插值函数。
----------
http://www.bimant.com/docs/glsl-es/cos/ >> (61ms) --> 
GLSL 中的 cos 函数文档描述cos 函数是计算给定角度的余弦值的 GLSL 内置函数。返回值的范围在 -1 到 1 之间。语法cos(x)参数x：以弧度表示的角度值。示例float angle = 1.2;float cosine = cos(angle);注意事项cos 函数的参数需要以弧度为单位。如果参数被定义成角度值，则需要将角度值转换为弧度值（角度 × π / 180）。在一些特定的场景下，调用 cos 函数可能会引起性能瓶颈。建议尽可能使用预计算或替代方案来减少调用次数。附录GLSL 版本：GLSL 1.00函数说明：GLSL 内置函数参考链接：cos 函数文档
----------
http://www.bimant.com/docs/glsl-es/cosh/ >> (87ms) --> 
GLSL cosh函数文档函数定义float cosh(float x);函数描述cosh函数返回参数x的双曲余弦值。双曲余弦值被定义为$ \frac{e^x + e^{-x}}{2}$。参数x: 要计算双曲余弦值的浮点数。返回值返回x的双曲余弦值。示例float x = 2.0;float result = cosh(x); // 结果为 3.762195注意事项x的值不能太大或太小，否则将导致精度损失或溢出。如果要计算双曲正弦值或双曲正切值，可以使用GLSL的sinh和tanh函数。
----------
http://www.bimant.com/docs/glsl-es/cross/ >> (89ms) --> 
GLSL cross函数文档简介cross函数是GLSL中的一个向量运算函数，用于计算两个3D向量的叉积，返回一个新的3D向量。叉积是非常常见的向量运算，可以用于计算面积、法向量、旋转轴等。函数原型vec3 cross(vec3 x, vec3 y)参数解释x：vec3类型，表示第一个3D向量。y：vec3类型，表示第二个3D向量。返回值返回一个新的vec3类型的向量，表示两个向量的叉积。使用示例vec3 v1 = vec3(1.0, 0.0, 0.0);vec3 v2 = vec3(0.0, 1.0, 0.0);vec3 v3 = cross(v1, v2); // v3 = vec3(0.0, 0.0, 1.0)注意事项cross函数只能用于计算两个3D向量的叉积，如果需要计算其他维度的向量叉积，可以自行实现。叉积的结果向量垂直于原先的两个向量。当两个向量平行时，叉积的结果是零向量。
----------
http://www.bimant.com/docs/glsl-es/dFdx/ >> (70ms) --> 
GLSL dFdx函数文档简介dFdx() 函数是GLSL中的一个内置函数，用于计算纹理坐标x方向上的偏导数。语法float dFdx(float p);描述dFdx() 函数返回参数 p 在x方向上的偏导数。参数p: 需要计算x方向上偏导数的值，类型为float。返回值dFdx() 函数返回 p 在x方向上的偏导数，类型为float。注意事项dFdx() 只能用于需要计算x方向上偏导数的场景中，对于y方向，可以使用 dFdy()。dFdx() 应当在shader中的main函数内使用。dFdx() 不保证在不同平台上都有相同的精度，因此不应该使用它来确定两个表面纹理坐标之间的距离。示例vec2 st = gl_FragCoord.xy / u_resolution;float xDist = 1.0 / u_resolution.x;float yDist = 1.0 / u_resolution.y;float dfdx = dFdx(st.x);float dfdy = dFdy(st.y);vec4 color = texture2D(u_texture, st);gl_FragColor = color + vec4(dfdx / xDist, dfdy / yDist, 0.0, 1.0);此示例演示了如何使用 dFdx() 来计算纹理坐标的x方向偏导数，并使用结果对每个像素着色。这使得渲染的图像在GIF图上获得了平滑的动画效果。参考资料OpenGL ES Shading Language 1.0.17 Specification
----------
http://www.bimant.com/docs/glsl-es/dFdy/ >> (50ms) --> 
dFdy函数文档函数说明dFdy函数是GLSL中的一个内置函数，用于计算函数在y方向（垂直于屏幕）上的导数。函数原型float dFdy(float p)参数p：要计算导数的表达式或变量。返回值返回p在y方向上的导数值。注意事项dFdy函数用于计算在屏幕上y方向上移动一个像素单位时产生的表达式或变量的变化量。dFdy函数只对2D或3D纹理采样器贴图和投影矩阵求逆操作有效。dFdy函数可能不被支持或表现不同于不同的GPU，因此建议进行兼容性测试和调试。示例uniform sampler2D texture;void main() { vec4 color = texture2D(texture, gl_TexCoord[0].xy); float gradient = dFdy(gl_TexCoord[0].y); gl_FragColor = color + vec4(gradient, 0.0, 0.0, 1.0);}在此示例中，我们使用texture2D内置函数从2D纹理采样器中获取颜色，并且我们使用dFdy函数获取屏幕上像素在y方向上的变化量。最后，我们将该变化量添加到纹理采样器的颜色中来创建一个渐变效果。
----------
http://www.bimant.com/docs/glsl-es/degrees/ >> (78ms) --> 
GLSL函数：degrees()函数名：degrees()描述GLSL degrees() 函数将给定角度的弧度值转换为角度。该函数将弧度值乘以180/π，从而将弧度转换为角度。语法float degrees(float radians)radians：用于转换为角度的弧度值。返回值返回一个浮点数，表示对应弧度值的角度数。示例float radians = 1.5708;float degrees = degrees(radians); // 90注意事项参数 radians 应该是一个表示弧度的浮点数值。应该使用给定的弧度值计算对应的角度值，以避免误差。应该注意单位制，确保在不同应用场景中的计算结果与期望相符。
----------
http://www.bimant.com/docs/glsl-es/determinant/ >> (74ms) --> 
GLSL determinant函数文档内容本文档将介绍GLSL中determinant函数的用法、参数及返回值等详细信息。determinant函数用于计算矩阵的行列式。语法float determinant(mat2 x);float determinant(mat3 x);float determinant(mat4 x);参数参数类型参数名描述mat2/mat3/mat4x指定的矩阵。返回值返回类型返回值描述float计算出的矩阵行列式的值。说明矩阵行列式是矩阵的一个标量值，是一个几何上的概念。它是用来表示线性变换对空间面积或空间体积的伸缩倍数的。行列式是矩阵的函数，因此它随矩阵的变化而变化。示例下面是一个mat2型矩阵计算行列式的代码示例：mat2 m = mat2(1.0, 2.0, 3.0, 4.0);float det = determinant(m);注意事项仅支持行列式计算。矩阵的列数应等于行数，否则会产生编译错误。当矩阵为奇异矩阵（即行列式为0）时，行列式函数将返回0。
----------
http://www.bimant.com/docs/glsl-es/distance/ >> (66ms) --> 
GLSL distance函数文档distance(p0, p1)函数计算两个点p0和p1的欧几里得距离。参数名称描述p0一个vec类型的点，代表第一个点p1一个vec类型的点，代表第二个点返回值两个点的欧几里得距离，类型为float。示例vec3 p0 = vec3(1.0, 2.0, 3.0);vec3 p1 = vec3(4.0, 5.0, 6.0);float dist = distance(p0, p1);上述代码将计算点p0和p1之间的欧几里得距离并将其存储在变量dist中。
----------
http://www.bimant.com/docs/glsl-es/dot/ >> (71ms) --> 
GLSL Dot函数dot(a, b) 函数返回两个向量 a 和 b 的点积（也称为内积）。两个向量的点积等于它们的长度乘积再乘以它们的夹角的余弦值。语法float dot(vec2 x, vec2 y);float dot(vec3 x, vec3 y);float dot(vec4 x, vec4 y);x: vec2, vec3 或 vec4 类型的向量。y: vec2, vec3 或 vec4 类型的向量。返回值: 两个向量的点积。示例vec3 a = vec3(1.0, 2.0, 3.0);vec3 b = vec3(4.0, 5.0, 6.0);float result = dot(a, b);// result = 1.0 * 4.0 + 2.0 * 5.0 + 3.0 * 6.0 = 32.0注意事项输入向量必须具有相同数量的分量，否则将返回编译错误。函数返回的值是标量类型，因此可以直接在 shader 代码中使用。
----------
http://www.bimant.com/docs/glsl-es/equal/ >> (76ms) --> 
GLSL Equal Function DocumentationFunction NameequalParametersThe equal function takes two arguments of any basic type, that is, any scalar or vector type of bool, int, uint or float.bool equal(T x, T y)Return ValueThe return value of the equal function is a bool that is true if x and y are equal or false otherwise. The function tests for exact equality between the values of x and y.DescriptionThe equal function performs an exact numeric comparison between x and y. For float values, the function simply tests whether the values are bit-for-bit identical. For integer values, the function tests whether they are exactly equal.For vector types, the comparison is performed component-wise. That is, each component of x is compared with the corresponding component of y, and if all components are equal, the function returns true. Otherwise, it returns false.ExampleThe following example demonstrates the use of the equal function to compare two float values and two vec3 vectors:float a = 2.5;float b = 2.5;vec3 v1 = vec3(1.0, 2.0, 3.0);vec3 v2 = vec3(1.0, 2.0, 3.0);bool c = equal(a, b); // returns truebool d = equal(v1, v2); // returns trueNotesThe equal function is a built-in function in GLSL, so it does not need to be declared or defined.NaN values are not considered equal to any other value, including themselves. Therefore, NaN values will always result in false when used with the equal function.
----------
http://www.bimant.com/docs/glsl-es/exp/ >> (59ms) --> 
GLSL exp 函数介绍exp 函数是 GLSL 中的一个内置指数函数，用于计算以自然底数 e 为底的指数函数值。float exp(float x);exp 函数接收一个浮点数参数 x，返回 e 的 x 次方。使用示例vec4 x = vec4(1.0, 2.0, 3.0, 4.0);vec4 y = exp(x);// y = vec4(2.718281828, 7.389056099, 20.08553692, 54.59815003)注意事项exp 函数的输入参数 x 可以是正数、负数或零。exp 函数的输出值在 x 大于或等于零时是正数，x 小于零时是小于一的正数，x 等于零时为 1。exp 函数的定义域不限于标准 IEEE 浮点数范围。注意 exp 函数计算的指数值在输入参数过大时会超出浮点数表示范围，输出值会返回 inf。在 shader 中使用 exp 函数时，需要开启 GL_ARB_gpu_shader_fp64 拓展。参考链接GLSL 4.60 Specification – 8.2 Exponential functions
----------
http://www.bimant.com/docs/glsl-es/exp2/ >> (70ms) --> 
GLSL exp2函数文档描述exp2函数在GLSL中是一个用于返回以2为底数的幂次方值的函数。该函数的计算公式为：$exp2(x) = 2^{x}$。声明float exp2(float x);vec2 exp2(vec2 x);vec3 exp2(vec3 x);vec4 exp2(vec4 x);参数x：浮点类型或向量类型，代表幂次方的指数。返回值float：计算结果为单个浮点数。vec2：计算结果为包含两个浮点数的向量。vec3：计算结果为包含三个浮点数的向量。vec4：计算结果为包含四个浮点数的向量。示例float res1 = exp2(4.0); // 计算结果为 16.0vec2 res2 = exp2(vec2(2.0, 3.0)); // 计算结果为 vec2(4.0, 8.0)vec3 res3 = exp2(vec3(1.0, 2.0, 3.0)); // 计算结果为 vec3(2.0, 4.0, 8.0)vec4 res4 = exp2(vec4(0.0, 1.0, 2.0, 3.0)); // 计算结果为 vec4(1.0, 2.0, 4.0, 8.0)注意事项参数类型必须是浮点类型或向量类型。不支持负数指数，若需要计算负数指数的幂次方，可以使用pow函数。
----------
http://www.bimant.com/docs/glsl-es/faceforward/ >> (98ms) --> 
GLSL函数文档：faceforward()函数说明faceforward() 函数用于判断向量朝向，它可以通过比较入射向量与几何法线的方向，是否一致确定向量朝向。函数原型bvec2 faceforward(bvec2 N, bvec2 I, bvec2 Nref);bvec3 faceforward(bvec3 N, bvec3 I, bvec3 Nref);bvec4 faceforward(bvec4 N, bvec4 I, bvec4 Nref);参数解释N：几何法线向量，即法向量。I：入射向量。Nref：法线参考向量。可以理解为“参照物”，通常为表面法线向量。返回值返回一个Boolean类型的向量。函数操作如果 $\text{dot}(\boldsymbol{N},\boldsymbol{Nref}) > 0$，则表示向量 $\boldsymbol{I}$ 从背面进入。如果 $\text{dot}(\boldsymbol{N},\boldsymbol{Nref}) < 0$，则表示向量 $\boldsymbol{I}$ 从正面进入。返回值为一个具有两个或三个分量的 Boolean 向量。示例示例1vec3 normal = normalize(normalMatrix * a_normal);vec3 lightDir = normalize(light.position - v_position);if (dot(normal, lightDir) < 0.0) { normal = -normal;}vec3 diffuse = max(dot(normal, lightDir), 0.0) * u_material.diffuse.rgb;在这个示例中，我们使用 dot() 函数来计算法线向量和光源方向向量之间的夹角。如果这个夹角小于 0，就意味着光线从物体的背面照射到表面上。我们可以使用 faceforward() 函数来修正这个问题。示例代码：vec3 normal = normalize(normalMatrix * a_normal);vec3 lightDir = normalize(light.position - v_position);normal = faceforward(normal, -lightDir, normal);vec3 diffuse = max(dot(normal, lightDir), 0.0) * u_material.diffuse.rgb;在这个示例中，我们使用了 faceforward() 函数来判断入射方向，如果被照射物体的法向量与光线方向相反，则法向量取反。示例2vec3 norm = normalize(N);vec3 toLight = normalize(u_lightPos - v_worldPos);vec3 toEye = normalize(u_eyePos - v_worldPos);vec3 reflection = reflect(-toLight, norm);// 计算菲涅耳反射float fresnel = pow(clamp(1.0 - dot(toEye, reflection), 0.0, 1.0), 5.0);vec4 fragColor = mix(texture(tex, v_texcoord), vec4(u_color, 1.0), fresnel);在这个示例中，我们使用了 reflect() 函数来计算反射向量。但是，在某些情况下，反射向量的方向可能与表面法向量相反，我们可以使用 faceforward() 函数来解决这个问题。示例代码：vec3 norm = normalize(N);vec3 toLight = normalize(u_lightPos - v_worldPos);vec3 toEye = normalize(u_eyePos - v_worldPos);vec3 reflection = reflect(-toLight, norm);reflection = faceforward(reflection, -toEye, norm);// 计算菲涅耳反射float fresnel = pow(clamp(1.0 - dot(toEye, reflection), 0.0, 1.0), 5.0);vec4 fragColor = mix(texture(tex, v_texcoord), vec4(u_color, 1.0), fresnel);在这个示例中，我们使用了 faceforward() 函数来保证反射向量的方向与表面法向量一致。
----------
http://www.bimant.com/docs/glsl-es/floatBitsToInt/ >> (69ms) --> 
floatBitsToInt函数文档该函数的作用是将浮点数转换为整数。它将输入浮点数的位模式视为有符号整数的位模式，然后将其转换为整数。函数原型int floatBitsToInt(float value)参数value：将要转换为整数的浮点数。返回值返回与 value 相对应的整数。示例float value = 2.5;int integerValue = floatBitsToInt(value);上面的示例中，value 的二进制表示为 0b01000000001000000000000000000000，它在转换为整数后将变为 1074266112。注意事项如需将整数转换为浮点数，请使用 intBitsToFloat 函数。该函数转换的结果与具体实现相关，在不同平台或实现中结果可能不同。
----------
http://www.bimant.com/docs/glsl-es/floatBitsToUint/ >> (52ms) --> 
GLSL floatBitsToUint函数文档简介floatBitsToUint函数是GLSL中的一个函数，用于将单精度浮点数（float类型）的位表示形式转化为一个无符号整数（uint类型）。该函数的函数原型如下所示：uint floatBitsToUint(float value);参数value：需要转化为无符号整数的单精度浮点数。返回值返回一个无符号整数，该整数的位表示形式与传入的单精度浮点数相同。使用示例下面是一个使用floatBitsToUint函数的例子：float value = -1.0;uint bits = floatBitsToUint(value);在这个例子中，我们将value设置为-1.0，然后使用floatBitsToUint函数将其转化为一个无符号整数bits。由于浮点数-1.0的相应位表示形式为0xbf800000，因此bits的值为0xbf800000。注意事项将单精度浮点数转化为无符号整数可能会导致精度丢失。该函数只适用于单精度浮点数。
----------
http://www.bimant.com/docs/glsl-es/floor/ >> (80ms) --> 
GLSL的floor函数floor()函数是在GLSL中常用的一个函数，它的作用是返回一个小于或等于参数的最大整数值。在GLSL中，函数原型为：float floor(float x);该函数接收一个float类型的参数x，返回一个float类型的最大整数值。如果x是正数或0，则该函数返回不大于x的最大整数值；如果x是负数，则返回的是不小于x的最小整数值。使用示例以下是floor()函数的几个使用示例：floor(3.7); // 3floor(0.2); // 0floor(-2.8); // -3注意事项floor()函数在数值计算中较为常用。对于整数类型的输入，floor()函数直接返回其本身。对于正负零，返回值与输入值相同。floor()函数会将输入值向下取整，即返回一个不大于输入值的最大整数值。如果参数x是NaN（不是数字），则结果也是NaN。参考资料GLSL中floor()函数的说明文档
----------
http://www.bimant.com/docs/glsl-es/fract/ >> (58ms) --> 
GLSL fract函数文档简介fract函数是OpenGL着色器语言（GLSL）中的一个内置函数。它用于获取给定数字的小数部分（即数字的小数部分），并返回一个值在0到1之间。语法float fract(float x)x - 需要获取小数部分的数字。它可以是任何类型的数字，包括整数和浮点数。返回值函数返回x的小数部分。描述fract函数返回输入参数的小数部分，即去除其整数部分后的余数。当输入参数为负数时，返回值也为负数。结果范围在0到1之间，包括0和1。例如，fract(3.14)将返回0.14。同样，fract(-2.5)将返回-0.5。对于整数，小数部分为0。示例float a = 3.14;float b = -2.5;float c = 5.0;float fa = fract(a); // fa = 0.14float fb = fract(b); // fb = -0.5float fc = fract(c); // fc = 0.0在上面的示例中，a的小数部分为0.14，b的小数部分为-0.5，c是整数，所以其小数部分为0。注意事项fract函数仅仅获取输入参数的小数部分，而不是四舍五入或截断它。如果需要四舍五入或截断小数，则需要使用其他函数。对于很小或很大的数字，fract函数可能会导致精度问题。在这种情况下，可能需要使用其他方法来计算小数部分。结论fract函数可用于获取数字的小数部分，并返回0到1之间的结果。对于比较大或比较小的数字，可能需要使用其他函数来处理小数部分。
----------
http://www.bimant.com/docs/glsl-es/fwidth/ >> (57ms) --> 
GLSL中的fwidth函数fwidth函数是一个GLSL内置函数，用于计算函数在屏幕空间（或者其他坐标系）中x和y方向的变化率，也就是函数沿着x和y方向的梯度。语法fwidth(in vec2 p) -> vec2p：要计算梯度的坐标。返回一个二维向量，向量的x分量表示函数沿着x轴的梯度，y分量表示函数沿着y轴的梯度。描述fwidth函数将在输入坐标周围做一个小的增量来计算梯度。这个增量通常等于纹理坐标的分辨率。对于输入坐标p，fwidth(p)的计算公式如下：fwidth(p) = abs(dFdx(p)) + abs(dFdy(p))其中：abs函数表示取绝对值。dFdx(p)表示函数在x轴上的偏导数。dFdy(p)表示函数在y轴上的偏导数。在默认情况下，fwidth函数是在片段着色器中使用的，通常用于计算像素变化、纹理采样和着色器后期处理等方面。示例下面是一个示例片元着色器，使用fwidth函数计算表面法线的偏导数，结果用于计算环境光的强度：uniform vec3 ambientColor;uniform vec3 lightColor;uniform vec3 lightDir;varying vec3 vNormal;void main() { vec3 n = normalize(vNormal); vec3 l = normalize(lightDir); float NdotL = dot(n, l); float intensity = max(0.0, NdotL);// 计算法线的偏导数 vec2 derivative = fwidth(gl_FragCoord.xy);// 加权环境光颜色 vec3 ambient = ambientColor * (1.0 - intensity*intensity); vec3 color = ambient + intensity * lightColor;// 应用边缘柔化 color *= exp(-(derivative.x + derivative.y)); gl_FragColor = vec4(color, 1.0);}您可以使用实际环境光颜色和光线方向替换shader中的uniform变量，以获得更好的结果。
----------
http://www.bimant.com/docs/glsl-es/gl_FragCoord/ >> (52ms) --> 
gl_FragCoordgl_FragCoord是一个内置的变量，在fragment shader中可用。它表示当前fragment的屏幕坐标。语法in vec4 gl_FragCoord;参数无返回值返回一个vec4类型的向量，包含当前fragment的屏幕坐标。gl_FragCoord.x表示当前fragment的x坐标。gl_FragCoord.y表示当前fragment的y坐标。gl_FragCoord.z表示当前fragment的深度值，取值范围为0.0到1.0。gl_FragCoord.w表示当前fragment的透明度，取值范围为0.0到1.0。示例以下示例代码计算当前fragment的颜色，使用fragment的x坐标除以屏幕的宽度作为红色通道值。void main() { vec2 resolution = vec2(1280.0, 720.0); vec4 fragColor = vec4(0.0); fragColor.x = gl_FragCoord.x / resolution.x; fragColor.y = gl_FragCoord.y / resolution.y; gl_FragColor = fragColor;}另请参阅GLSL中的内置变量
----------
http://www.bimant.com/docs/glsl-es/gl_FragDepth/ >> (51ms) --> 
gl_FragDepth函数文档简介gl_FragDepth是一个内置的变量，它可以用来设置像素的深度值。这个变量只能在fragment shader中使用，作用是控制每个像素的z值。语法out float gl_FragDepth;参数gl_FragDepth是一个float类型的变量，它表示对应像素的z值。这个z值是在纹理空间中的z值，也就是深度值。返回值gl_FragDepth没有返回值。示例void main() { gl_FragDepth = 0.5;}这个示例代码将深度值设置为0.5。注意事项gl_FragDepth只影响像素的深度值，不影响颜色值；gl_FragDepth的取值范围是[0,1]；gl_FragDepth的默认值是当前像素的深度值。
----------
http://www.bimant.com/docs/glsl-es/gl_FrontFacing/ >> (60ms) --> 
GLSL - gl_FrontFacing函数该函数返回当前绘制面的朝向, 也就是判断当前多边形正面是否面向观察者。语法bool gl_FrontFacing();描述gl_FrontFacing() 函数将返回一个布尔值，代表当前正在绘制的面是否朝向观察者。如果该多边形正面朝向观察者，则返回 true，否则返回 false。该函数只能在顶点和“片段”着色器中使用，并且只有在启用面剔除时才有效。示例以下示例代码定义了一个“片段”着色器，根据多边形的正面朝向设置输出颜色：#version 330in vec4 fragColor;out vec4 outColor;void main(){ if (gl_FrontFacing()) outColor = fragColor; else outColor - vec4(1.0, 0.0, 0.0, 1.0);}在上述示例中，如果正在绘制正面，则输出颜色为多边形的颜色，否则为红色。参考GLSL版本：#version 330，#version 可替换为您使用的版本。gl_FrontFacing() 函数仅适用于启用了面剔除功能。该函数只能在顶点和“片段”着色器中使用。以上是对 gl_FrontFacing() 函数的一个简单介绍。通过阅读文档，您应该能够更好地理解如何在GLSL中使用它。
----------
http://www.bimant.com/docs/glsl-es/gl_InstanceID/ >> (57ms) --> 
GLSL函数文档：gl_InstanceID描述gl_InstanceID是一个GLSL内置函数，用来获取当前实例的ID（标识符），用于支持实例渲染技术，例如使用glDrawArraysInstanced或glDrawElementsInstanced函数绘制多个实例时。语法gl_InstanceID参数该函数没有参数。返回值该函数返回当前实例的ID，类型为int。示例#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main(){ gl_Position = projection * view * model * vec4(aPos, 1.0); gl_InstanceID;// 获取当前实例的ID}注意事项该函数只能在着色器（shader）代码的顶点着色器（vertex shader）或几何着色器（geometry shader）中使用。如果没有使用实例渲染（instance rendering）技术，则该函数返回值始终为0。使用实例渲染技术时，多个实例共享同一份着色器程序（shader program），因此该函数返回的实例ID会根据各个实例的不同而有所不同。
----------
http://www.bimant.com/docs/glsl-es/gl_PointCoord/ >> (70ms) --> 
GLSL函数文档：gl_PointCoord()名称gl_PointCoord() - 获取点精灵的纹理坐标。声明vec2 gl_PointCoord();描述gl_PointCoord() 函数返回当前片段中点精灵的纹理坐标。点精灵默认情况下是 $1.0 \times 1.0$ 的正方形。纹理坐标的范围是 $(0.0, 0.0)$ 到 $(1.0, 1.0)$。 纹理坐标对应于点精灵的区域，其中 $(0.0, 0.0)$ 是左下角，$(1.0, 1.0)$ 是右上角。gl_PointCoord() 函数只能用于点渲染模式。在其他渲染模式下使用该函数将导致不确定的行为。返回值函数返回当前片段中点精灵的纹理坐标。示例uniform sampler2D texture;void main() { vec2 textureCoords = gl_PointCoord(); gl_FragColor = texture2D(texture, textureCoords);}在这个例子中，我们将点精灵的纹理坐标作为纹理采样的输入，使用 texture2D() 去获取纹理中对应坐标的颜色，并将结果输出到屏幕上。注意事项gl_PointCoord() 函数只能在片段着色器中使用。gl_PointCoord() 函数只适用于点渲染模式。如果点精灵是由外部几何着色器生成的，那么 gl_PointCoord() 应该在片段着色器中使用。如果点精灵是使用内部渲染管线生成的，则可以在几何着色器或片段着色器中使用该函数。gl_PointCoord() 返回的纹理坐标对于点精灵是固定的，除非使用着色器修改纹理坐标或更改点精灵大小。
----------
http://www.bimant.com/docs/glsl-es/gl_PointSize/ >> (68ms) --> 
GLSL gl_PointSize 函数文档函数描述gl_PointSize 函数用于设置点的大小。它可以在顶点着色器中使用。声明语法：void gl_PointSize(float size);输入参数size：指定点的大小。默认值为1.0。备注在片段着色器中，通过 gl_PointCoord 可以获取当前像素在点中所处的位置，从而可以在片段着色器中实现更复杂的点着色效果。示例#version 330in vec3 position;void main(){ gl_Position = vec4(position, 1.0); gl_PointSize = 20.0;}这个示例给每个点设置了大小为20个像素。
----------
http://www.bimant.com/docs/glsl-es/gl_Position/ >> (68ms) --> 
gl_Position该函数是一个内建的着色器函数，在OpenGL中用于计算顶点的最终位置。参数void main(){ gl_Position = vec4(position, 1.0);}在该代码中，gl_Position为一个四维向量，其前三个分量分别表示顶点的X、Y、Z坐标，最后一个分量为齐次坐标的值，通常为1.0。position为传递到着色器中的顶点位置变量。返回值该函数不返回任何值，但会将计算得到的顶点位置赋值给gl_Position。注意事项在顶点着色器中，gl_Position是一个必须要赋值的内建变量。如果没有正确赋值，OpenGL则无法正确渲染顶点。在使用gl_Position时，需要保证其值是在裁剪空间内的坐标。如果没有正确的变换和投影矩阵，可能会得到错误的结果。
----------
http://www.bimant.com/docs/glsl-es/gl_VertexID/ >> (74ms) --> 
gl_VertexID函数文档函数说明：该函数返回当前正在处理的顶点的索引值。函数原型：in int gl_VertexID参数说明：无参数。返回值：当前正在处理的顶点的索引值，为整型。用法示例：void main(){ // 获取当前顶点的索引值 int index = gl_VertexID; ...}注意事项：该函数只对渲染管线的Vertex Shader阶段有效。在此阶段中，gl_VertexID函数可以用来获取当前正在处理的顶点的索引。该函数返回值的取值范围为从0到当前渲染的顶点总数减一的范围，因为顶点索引是从0开始计数的。在使用该函数时，需要注意顶点索引值是否越界，以避免出现错误。顶点索引值可以用来访问相应的顶点数据，比如顶点坐标、法线、纹理坐标等。
----------
http://www.bimant.com/docs/glsl-es/greaterThan/ >> (68ms) --> 
greaterThan函数文档函数声明bool greaterThan(T x, T y)函数描述函数 greaterThan 用于比较两个值 x 和 y 是否满足 "x > y" 的条件。如果 x 大于 y，则返回 true，否则返回 false。该函数接受任意类型 T，包括但不限于数字、矢量和矩阵类型。参数x：待比较的第一个值。y：待比较的第二个值。返回值函数将返回布尔值 true 或 false，表示 x 是否大于 y。示例以下示例将演示 greaterThan 函数的用法：float a = 5.0;float b = 3.0;bool result = greaterThan(a, b);// result 的值为 true，因为 a 大于 bvec3 v1 = vec3(1.0, 2.0, 3.0);vec3 v2 = vec3(4.0, 5.0, 2.0);bvec3 result = greaterThan(v1, v2);// result 的值为 bvec3(false, false, true)，因为 v1 的第三个分量大于 v2 的第三个分量mat2x3 m1 = mat2x3(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);mat2x3 m2 = mat2x3(6.0, 5.0, 4.0, 3.0, 2.0, 1.0);bmat2x3 result = greaterThan(m1, m2);// result 的值为 bmat2x3(false, false, false, true, true, true)，// 因为 m1 中的每个元素都小于 m2 中的对应元素注意事项greaterThan 函数在比较简单类型（如标量）时，效率更高。对于矢量和矩阵类型，比较的是它们的元素。当两个值的元素类型不同时，该函数将导致编译错误。
----------
http://www.bimant.com/docs/glsl-es/greaterThanEqual/ >> (62ms) --> 
GLSL Greater Than or Equal Function DocumentationThe greaterThanEqual() function in GLSL is used to compare two values and return a boolean result indicating whether the first value is greater than or equal to the second value.Syntaxbool greaterThanEqual(T x, T y)x: The first value to be compared, of any type T.y: The second value to be compared, of the same type T as x.Return ValueThe greaterThanEqual() function returns a boolean value indicating whether x is greater than or equal to y. If x is greater than or equal to y, it returns true. Otherwise, it returns false.Example usage:float a = 5.0;float b = 3.0;bool result = greaterThanEqual(a, b); // Returns trueint x = 10;int y = 20;bool result = greaterThanEqual(x, y); // Returns falsevec3 p = vec3(1.0, 2.0, 3.0);vec3 q = vec3(1.0, 0.0, 5.0);bvec3 result = greaterThanEqual(p, q); // Returns bvec3(true, true, false)NotesThe greaterThanEqual() function can only be used with numerical data types (float, int, uint, double) and vectors/matrices composed of numerical data types.The comparison is performed element-wise in the case of vectors and matrices.For vectors and matrices, the greaterThanEqual() function returns a boolean vector/matrix in which each element of the result corresponds to the comparison of the respective elements of the input vectors/matrices.The greaterThanEqual() function is part of the GLSL version 1.20 specification and is supported by most modern GPUs.
----------
http://www.bimant.com/docs/glsl-es/intBitsToFloat/ >> (487ms) --> 
GLSL intBitsToFloat() 函数文档函数简述intBitsToFloat() 函数可以将 32 位整数解释为单精度浮点数值。float intBitsToFloat(int value)参数value：32 位整数值。返回值value 解释为单精度浮点数值。示例int intValue = 1065353216; // 表示 1.0 的 IEEE 754 二进制形式float floatValue = intBitsToFloat(intValue); // 将 intValue 解释为单精度浮点数值// floatValue 等于 1.0注意事项value 参数必须是 32 位整数。函数只负责将 32 位整数解释为浮点数，并不同于 floatBitsToInt() 函数将浮点数解释为整数。更多信息关于函数的详细解释可以参考『OpenGL 4.6Core Profile规范』的第 86 页。相关函数floatBitsToInt(): 将单精度浮点数解释为 32 位整数。uintBitsToFloat(): 将无符号整数解释为单精度浮点数。floatBitsToUint(): 将单精度浮点数解释为无符号整数。
----------
http://www.bimant.com/docs/glsl-es/inverse/ >> (1994ms) --> 
GLSL inverse函数文档简述GLSL中的inverse函数用于计算一个矩阵的逆矩阵。由于逆矩阵并不是所有矩阵都有的，所以在使用inverse函数前应该确认输入的矩阵是可逆的。函数原型mat4 inverse(mat4 m)mat3 inverse(mat3 m)参数m：需要逆矩阵的矩阵返回值inverse(mat4 m)：返回mat4类型的逆矩阵inverse(mat3 m)：返回mat3类型的逆矩阵注意事项mat3类型的矩阵在进行逆矩阵计算时，只计算其前3x3的部分，即它的右下角一定是1。一个矩阵是否可逆取决于它的行列式是否为0。在使用inverse函数前需要检查输入矩阵的行列式是否为0，如果是，则不能使用inverse函数。示例mat4 m = mat4( 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0);float det = determinant(m); // 先计算m的行列式if (det != 0.0) { mat4 mInv = inverse(m); // 如果m可逆，则计算m的逆矩阵 // 逆矩阵的使用} else { // m不可逆，不进行inverse函数的计算}
----------
http://www.bimant.com/docs/glsl-es/inversesqrt/ >> (51ms) --> 
inversesqrt 函数函数描述inversesqrt 函数返回一个数的倒数的平方根。此函数等价于 1.0 / sqrt(x)，但是比直接计算结果更快。函数原型float inversesqrt(float x);参数x：需要计算其倒数的平方根的数值。必须大于0。返回值返回 x 的倒数的平方根的浮点数值。示例vec2 v = vec2(3.0, 8.0);float invsqrt = inversesqrt(v.x);在此示例中，计算了一个二维向量的第一个分量 3.0 的倒数的平方根，结果为 0.57735。
----------
http://www.bimant.com/docs/glsl-es/isinf/ >> (510ms) --> 
GLSL isinf()函数文档函数原型：bool isinf(float x);bool isinf(vec2 x);bool isinf(vec3 x);bool isinf(vec4 x);函数说明：GLSL的isinf()函数用于判断给定参数是否为正无穷或负无穷。该函数返回布尔类型 true 或 false。如果参数是+∞或-∞，则返回 true。如果参数是任何其他值，则返回 false。参数：函数的输入参数可以是以下任何数据类型 ：floatvec2vec3vec4请注意，如果输入参数为NaN，则返回值也为false。返回值：isinf()函数返回布尔值 true 或 false。示例：float x = 1.0/0.0; // x为+∞bool inf = isinf(x); // 返回truefloat y = -1.0/0.0; // y为-∞bool inf1 = isinf(y); // 返回truefloat z = 100.0; // z不是无穷大bool inf2 = isinf(z); // 返回falsevec4 vector = vec4(1.2, 3.0, -1.5, 0.0);vec4 result = isinf(vector); // 返回vec4(false, false, false, false)注意事项：即使编译器能够检测到某个值是否是无穷大，用户仍然需要手动检查。isinf()函数即使在计算表达式时使用也是有效的。对于非标量参数，isinf()函数将按元素方式操作，即对于每个参数向量中的元素，该函数将返回一个相应的true或false值。
----------
http://www.bimant.com/docs/glsl-es/isnan/ >> (918ms) --> 
GLSL isnan()函数使用说明函数描述GLSL（OpenGL Shader Language）中的isnan()函数用于判断一个浮点数是否为 NaN（Not-a-Number）。语法bool isnan(float x);参数说明x：需要判断是否为 NaN 的浮点数。返回值如果 x 是 NaN，则返回 true；否则，返回 false。示例float a = 10.0 / 0.0;// a 的值为 Infinityfloat b = a / a;// b 的值为 NaNbool r = isnan(b);// r 的值为 true注意事项如果使用isnan()函数时，参数不是浮点数类型，则编译器将报错。由于 NaN 的比较永远返回 false，因此不能将 NaN 用于等于和不等于比较。参考链接GLSL语言规范
----------
http://www.bimant.com/docs/glsl-es/length/ >> (1046ms) --> 
GLSL的length函数文档介绍length函数是GLSL语言中的向量函数之一，用于计算一个向量的长度（模）。语法float length(vec2 x);float length(vec3 x);float length(vec4 x);x为一个vec2、vec3或vec4类型的向量参数，返回值为一个float类型的数值，表示该向量的长度（模）。描述该函数的返回值为向量x的长度，计算公式为：length(x) = sqrt(dot(x, x));其中dot函数表示内积运算，即两个向量的对应元素相乘后相加的和。sqrt函数表示开方运算。该函数具有与向量长度相关的一些数学性质，例如：length(x)永远是非负数。当且仅当向量x等于零向量时，length(x)为零。对于任意标量s，length(s*x) = abs(s) * length(x)。示例vec3 position = vec3(1.0, 2.0, 3.0);float len = length(position); // len的值为sqrt(1.0*1.0 + 2.0*2.0 + 3.0*3.0)参考资料GLSL ES 3.00 specification - Section 8.3 Vector Functions
----------
http://www.bimant.com/docs/glsl-es/lessThan/ >> (63ms) --> 
GLSL函数文档：lessThan()描述lessThan()是一个GLSL函数，用于比较两个向量元素是否小于对应的元素。该函数返回一个布尔向量，其中每个分量分别表示对应元素是否小于另一个向量中对应的元素。语法bvec lessThan(vecType x, vecType y)bvec lessThan(ivecType x, ivecType y)参数x：一个vecType或ivecType类型的向量，表示被比较的向量。y：一个vecType或ivecType类型的向量，表示用于比较的向量。返回值函数返回一个bvec类型的向量，其中每个分量分别表示对应元素是否小于另一个向量中对应的元素。示例vec4 a = vec4(1.0, 2.0, 3.0, 4.0);vec4 b = vec4(2.0, 3.0, 1.0, 5.0);bvec4 result = lessThan(a, b);// result is: bvec4(true, true, false, true)注意事项参数必须具有相同的大小和类型。所有元素必须可以进行小于比较，否则结果是未定义的。
----------
http://www.bimant.com/docs/glsl-es/lessThanEqual/ >> (64ms) --> 
GLSL函数文档：lessThanEqual函数功能该函数用于执行逐元素比较，并返回一个布尔向量标识左向量每个元素是否不小于或等于右向量的对应元素。函数原型bvec lessThanEqual(genType x, genType y)该函数的具体输入和输出格式取决于 genType。当 genType 是 float 型时，函数原型为：bvec lessThanEqual(vec2 x, vec2 y)bvec lessThanEqual(vec3 x, vec3 y)bvec lessThanEqual(vec4 x, vec4 y)参数说明x, y 和返回值的类型必须是一个浮点向量类型，即 vec2、vec3 或 vec4。输入的参数 x 和 y 表示要比较大小的左右向量，返回值表示比较结果。返回值该函数返回一个布尔向量 bvec，指示左向量每个元素是否大于或等于右向量的对应元素。换言之，bvec[i] 等于 x[i] <= y[i]。示例以下示例展示了向量 x 中的每个元素是否不小于或等于向量 y 的对应元素：vec4 x = vec4(1.0, 2.0, 3.0, 4.0);vec4 y = vec4(0.0, 2.0, 5.0, 5.0);bvec result = lessThanEqual(x, y); // 0101即 result.x = false，result.y = true，result.z = true，result.w = false。注意事项注意要使用 GLSL 版本 1.30 或更高版本兼容的数据类型。如果给定的两个向量具有不同的大小，则应将更小的向量扩展为相同大小的向量，然后再调用 lessThanEqual()。参考资料The OpenGL ES Shading Language
----------
http://www.bimant.com/docs/glsl-es/log/ >> (60ms) --> 
GLSL log() 函数文档GLSL 的 log() 函数可以计算以指定底数为基数的对数。函数原型为：float log(float x, float base);其中，x 是要计算对数的值，base 是对数的底数。返回值为 float 类型，表示计算得到的对数值。示例计算以 2 为底的对数：float result = log(8.0, 2.0);// result 的值为 3.0注意事项x 和 base 的值必须都为正数。如果 x 或 base 为负数，则结果为 NaN。如果 x 或 base 为零，则结果为负无穷。如果 base 的值为 1，则结果为 NaN。如果 x 的值为 1，则结果为 0。如果 x 或 base 的值超出了浮点数表示范围，则结果为 inf 或 NaN。参考资料GLSL ES 3.00 Specification - Logarithm Functions
----------
http://www.bimant.com/docs/glsl-es/log/ >> (3756ms) --> 
GLSL log() 函数文档GLSL 的 log() 函数可以计算以指定底数为基数的对数。函数原型为：float log(float x, float base);其中，x 是要计算对数的值，base 是对数的底数。返回值为 float 类型，表示计算得到的对数值。示例计算以 2 为底的对数：float result = log(8.0, 2.0);// result 的值为 3.0注意事项x 和 base 的值必须都为正数。如果 x 或 base 为负数，则结果为 NaN。如果 x 或 base 为零，则结果为负无穷。如果 base 的值为 1，则结果为 NaN。如果 x 的值为 1，则结果为 0。如果 x 或 base 的值超出了浮点数表示范围，则结果为 inf 或 NaN。参考资料GLSL ES 3.00 Specification - Logarithm Functions
----------
http://www.bimant.com/docs/glsl-es/matrixCompMult/ >> (942ms) --> 
GLSL的matrixCompMult函数简介matrixCompMult 是 GLSL 中的一个矩阵函数，在 GLSL 的 GLSL.std.450 标准中定义。这个函数主要用于执行逐元素乘法计算一个矩阵和另一个矩阵的乘积。函数原型以下是函数的原型：mat(matrixCompMult)(mat<mxn, k> x, mat<k, pxn> y)参数 1：mat<mxn, k> x矩阵 x，它必须有 mxn 行，k 列。参数 2：mat<k, pxn> y矩阵 y，它必须有 k 行，pxn 列。返回值此函数返回一个大小为 mxp 的矩阵，其每个元素都是参数矩阵的对应元素相乘之后的结果。例子下面是一个示例：mat3x2 a = mat3x2(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);mat2x3 b = mat2x3(7.0, 8.0, 9.0, 10.0, 11.0, 12.0);mat3x3 result = matrixCompMult(a, b);注意事项注意，该函数执行的是逐个元素的乘法，并不是矩阵乘法。矩阵乘法需要使用乘法运算符 (*) 执行，而不是该函数。该函数逐行操作矩阵，因此矩阵的行数应该匹配。该函数逐列操作矩阵，因此矩阵的列数也应该匹配。如果大小不匹配，则此函数将导致运行时错误。矩阵元素的类型应相同。此函数不适用于非矩形数组或非平面数组类型。
----------
http://www.bimant.com/docs/glsl-es/max/ >> (67ms) --> 
GLSL max函数文档函数原型float max(float x, float y);vec2 max(vec2 x, vec2 y);vec3 max(vec3 x, vec3 y);vec4 max(vec4 x, vec4 y);函数说明max函数返回两个参数中较大的一个。对于标量参数，返回值是一个标量float类型。对于向量参数，返回值是一个相同维度的向量，且每个元素是对应位置上两个向量元素中的较大值。参数说明x: 第一个参数，可以是标量或向量y: 第二个参数，可以是标量或向量示例float max_val = max(3.0, 2.0);vec2 max_vec2 = max(vec2(1.0, 2.0), vec2(3.0, 1.0));vec3 max_vec3 = max(vec3(1.0, 3.0, 2.0), vec3(2.0, 1.0, 4.0));vec4 max_vec4 = max(vec4(4.0, 2.0, 5.0, 1.0), vec4(3.0, 1.0, 6.0, 2.0));输出结果:max_val = 3.0max_vec2 = vec2(3.0, 2.0)max_vec3 = vec3(2.0, 3.0, 4.0)max_vec4 = vec4(4.0, 2.0, 6.0, 2.0)
----------
http://www.bimant.com/docs/glsl-es/min/ >> (474ms) --> 
GLSL min函数文档说明在GLSL中，min函数用于返回两个数值中的最小值，并且适用于各种数据类型，包括浮点型、整型、布尔型和向量等。语法min(x, y)x: 第一个参数，可为任意数据类型。y: 第二个参数，与x数据类型相同。返回值返回x和y中的最小值，数据类型与输入参数相同。示例1计算两个浮点数的最小值：float a = 2.5;float b = 3.8;float min_val = min(a, b);// min_val的值为2.5示例2计算两个向量各个元素中的最小值：vec3 u = vec3(2.0, 3.0, 1.0);vec3 v = vec3(1.0, 4.0, 2.0);vec3 min_val = min(u, v);// min_val的值为(1.0, 3.0, 1.0)示例3计算两个布尔型值的最小值：bool m = true;bool n = false;bool min_val = min(m, n);// min_val的值为false注意事项只有两个参数。参数要求数据类型相同。如果参数中存在一个NaN或Inf，则返回元素值为NaN或Inf的那个参数。对于向量类型，min函数会对各个元素进行逐一比较，返回一个新的向量类型。
----------
http://www.bimant.com/docs/glsl-es/mix/ >> (72ms) --> 
GLSL mix()函数文档概述mix()函数是在GLSL中用于混合两个标量、向量或颜色的函数。它的作用是基于第三个参数 alpha，在两个值之间进行线性插值。它的签名如下：mix(x, y, alpha)其中，x和y参数可以是标量、向量或颜色，alpha参数是一个标量，表示在两个值之间混合的比例。参数x要混合的第一个值，可以是标量、向量或颜色。y要混合的第二个值，可以是标量、向量或颜色，该值必须与参数x具有相同类型和长度。alpha一个标量参数，指定如何混合两个值。值介于0和1之间，其中0表示完全使用x，1表示完全使用y。返回值返回一个和x和y类型和长度相同的值，表示通过线性插值后的值。示例以下是一些调用mix()函数的示例：mix(2.0, 5.0, 0.25);// 返回2.25mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.5);// 返回 (0.5, 0.5, 0.0)mix(vec4(1.0, 0.0, 0.0, 1.0), vec4(0.0, 1.0, 0.0, 1.0), 0.5);// 返回 (0.5, 0.5, 0.0, 1.0)注意事项参数x和y必须是相同类型和长度，否则会出现编译错误。参数alpha必须介于0和1之间，否则会产生不可预测的结果。参考文献The Official OpenGL Shading Language Specification (version 1.50)
----------
http://www.bimant.com/docs/glsl-es/mod/ >> (1982ms) --> 
GLSL mod()The mod() function is a built-in function in the GLSL shading language that computes the remainder of the division \a / \b. It returns the value a - b * trunc(a / b).The mod() function takes two arguments, both of which must be the same data type. The function returns a value with the same data type as the input arguments.SyntaxThe syntax for the mod() function is as follows:T mod(T a, T b)Where:T is any valid GLSL data type, such as float, vec2, vec3, vec4, int, ivec2, ivec3, ivec4, bool, bvec2, bvec3, bvec4, mat2, mat3, mat4, and so on.a is the dividend, the numerator of the division.b is the divisor, the denominator of the division.The mod() function can also be called with a single argument, in which case it returns the same value as the input argument, but with a positive sign. This is equivalent to calling mod(a, a).Examplefloat a = 16.0;float b = 3.0;float result = mod(a, b); // result = 1.0In this example, the mod() function is used to compute the remainder of the division 16 / 3, which gives a remainder of 1.RestrictionsThe mod() function has some restrictions in GLSL:The divisor must be non-zero. If the divisor is zero, the behavior of the function is undefined.The dividend and divisor must be of the same data type.For floating-point types, the behavior of mod() is undefined if the divisor or dividend is NaN.See AlsoTrigonometric functionsMath functionsGLSL language specification
----------
http://www.bimant.com/docs/glsl-es/modf/ >> (967ms) --> 
GLSL modf 函数文档说明GLSL 中的 modf 函数用于将一个浮点数拆分成整数部分和小数部分。vec2 modf(float x, out float i);x：待拆分的浮点数i：拆分后的整数部分，通过引用传递返回值为 vec2 类型，包含两个值：vec2.x：拆分后的小数部分vec2.y：拆分后的整数部分，与传入的参数 i 相同示例float x = 3.2;float i;vec2 parts = modf(x, i);float fractional = parts.x;float integer = parts.y;通过上述代码，我们可以将变量 x 拆分成小数部分和整数部分（注意，整数部分是通过引用传递的 i 变量）。注释modf (C++ Reference)：https://www.cplusplus.com/reference/cmath/modf/GLSL modf() 函数文档：https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/modf.xhtml
----------
http://www.bimant.com/docs/glsl-es/normalize/ >> (1984ms) --> 
GLSL normalize函数文档该函数用于将一个向量规范化（长度为1），常用于计算光照、法线等。函数原型vec3 normalize(vec3 x)参数：x：需要被规范化的向量返回值：返回一个长度为1的向量函数描述normalize函数将一个向量x除以它的长度，从而得到一个方向相同但长度为1的向量。如果x是一个零向量，则返回(0,0,0)。vec3 normalize(vec3 x) { float len = length(x); if (len < EPSILON) { return vec3(0.0); } return x / len;}其中，EPSILON是一个非常小的数，用于避免除以0的情况出现。使用范例vec3 v = vec3(1.0, 1.0, 1.0);vec3 n = normalize(v);这里将向量(1, 1, 1)规范化，得到一个方向相同但长度为1的向量。注意事项在计算过程中会进行开方操作，会影响性能；如果输入向量的长度非常小，规范化后可能会失去精度，需要使用EPSILON进行处理。如果长度为0的话，会处理成无限小，需要注意。
----------
http://www.bimant.com/docs/glsl-es/not/ >> (427ms) --> 
GLSL Not FunctionThe not function in GLSL is used to perform the logical negation (i.e., inverse) operation on a boolean value. Its syntax is as follows:bool not(bool x)ParametersThe not function takes a single parameter, which must be a boolean value (true or false) represented by the bool data type.Return ValueThe not function returns the logical inverse (i.e., negation) of the boolean value passed to it. If the input value is true, not will return false, and vice versa.Example UsageThe following example demonstrates the usage of the not function:bool x = true;bool y = not(x);// y is now falseNotesIn GLSL, true and false are represented by the bool data type, which is a built-in data type in the language.The not function can be used in combination with other logical operators (such as and, or, and xor) to create more complex logical expressions.
----------
http://www.bimant.com/docs/glsl-es/notEqual/ >> (507ms) --> 
GLSL notEqual函数文档概述notEqual函数用于比较两个值是否不相等。它返回一个布尔值表示两个值是否不相等。语法bool notEqual(T x, T y)参数x: 第一个要比较的值。y: 第二个要比较的值。T可以是如下类型中的任意一种：intfloatvec2vec3vec4ivec2ivec3ivec4bvec2bvec3bvec4返回值true：如果x和y的值不相等。false：如果x和y的值相等。示例下面是notEqual函数的使用示例：vec3 color1 = vec3(1.0, 0.5, 0.2);vec3 color2 = vec3(0.8, 0.5, 0.2);bool isEqual = notEqual(color1, color2);if(isEqual) { // do something}在上面的示例中，我们比较了两个颜色向量color1和color2是否相等。如果它们不相等，isEqual将为true。
----------
http://www.bimant.com/docs/glsl-es/outerProduct/ >> (910ms) --> 
outerProductmat3 outerProduct(vec3 c, vec3 r);FunctionComputes the outer product between two vectors, which is a matrix.Parametersc - The column vector (vec3) to be used for the outer product.r - The row vector (vec3) to be used for the outer product.Returnmat3 - A 3x3 matrix resulting from the outer product between c and r.DescriptionThe outer product between two vectors is defined as follows:outerProduct(c, r) = [c.x * r.x, c.x * r.y, c.x * r.z; c.y * r.x, c.y * r.y, c.y * r.z; c.z * r.x, c.z * r.y, c.z * r.z]This function allows creating a matrix from two vectors by using one as the column and the other as the row.Examplevec3 c = vec3(1.0, 2.0, 3.0);vec3 r = vec3(4.0, 5.0, 6.0);mat3 m = outerProduct(c, r);This will create a matrix m with the following values:m = [4.0,5.0,6.0; 8.0, 10.0, 12.0;12.0, 15.0, 18.0 ]See AlsoGLSL mat3 typeGLSL vec3 type
----------
http://www.bimant.com/docs/glsl-es/packHalf2x16/ >> (65ms) --> 
GLSL packHalf2x16函数文档函数描述uint packHalf2x16(vec2 value)packHalf2x16函数将一个vec2类型的浮点数向量value转换为一个32位无符号整数，该整数中的前16位存储value.x的16位表示，后16位存储value.y的16位表示。这种转换技术可以降低数据所占的存储空间。参数value: 需要进行转换的浮点数向量，其每个分量的范围为[0，1]。返回值返回一个32位无符号整数类型的值，其前16位存储value.x的16位表示，后16位存储value.y的16位表示。使用示例vec2 val = vec2(0.5, 0.75);uint packedVal = packHalf2x16(val);上面的示例将vec2类型的浮点数向量val转换为32位无符号整数类型的值packedVal。注意事项packHalf2x16函数只能处理浮点数向量的分量值范围为[0, 1]的情况，否则会返回错误的结果。转换过程中，浮点数向量各分量的值会被截断为16位，可能会导致精度损失。
----------
http://www.bimant.com/docs/glsl-es/packSnorm2x16/ >> (69ms) --> 
GLSL函数packSnorm2x16文档该函数将两个标准化的浮点数 (-1.0 到 1.0) 打包成一个 16 bit 的无符号整数类型。其中，第一个浮点数转换为 16 bit 有符号固定点数，第二个浮点数转换为 16 bit 有符号固定点数，最终将它们拼成一个 32 bit 无符号整数。声明uint packSnorm2x16(vec2 v)参数v ：调用函数时传入的参数，类型为 vec2。包含两个需要打包成无符号整数类型的标准化浮点数。返回值该函数的返回值为无符号整数类型 uint。注意事项该函数可以用于压缩两个浮点数到一个 32 bit 无符号整数类型中，便于传输和储存。该函数打包的两个浮点数必须在标准化范围内，否则可能出现错误。packSnorm2x16 函数返回的无符号整数类型可以用于 glTexImage2D 函数的 format 参数。示例下面的代码示例演示了如何使用 packSnorm2x16 函数：vec2 input = vec2(0.5, -0.3);uint output = packSnorm2x16(input);// 将 input 中的两个浮点数打包成一个 16 bit 的无符号整数类型算法该函数操作的算法如下：将第一个浮点数乘以 32767.0，并且将其向下取整得到有符号 16 bit 固定点数。将第二个浮点数乘以 32767.0，并且将其向下取整得到有符号 16 bit 固定点数。最终将两个有符号固定点数拼成一个 32 bit 的无符号整数类型。其中，前 16 bit 存储第一个数，后 16 bit 存储第二个数。参考链接GLSL ES 1.00 Specification
----------
http://www.bimant.com/docs/glsl-es/packUnorm2x16/ >> (945ms) --> 
GLSL函数packUnorm2x16文档函数描述uint packUnorm2x16(vec2 value)packUnorm2x16是一个GLSL的内置函数，用于将双精度浮点数向量value中的两个值以无符号16位整数（即[0, 2^16-1]范围内的整数）的形式打包成一个32位无符号整数返回。这个函数会将每个输入值从[0, 1]的范围中线性映射到[0, 2^16-1]的范围内。参数列表value：类型为vec2的双精度浮点数向量，其中包含要打包的两个值。返回值类型：uint返回值为将两个输入值打包成的32位无符号整数。示例示例1vec2 color = vec2(0.5, 0.75);uint packedValue = packUnorm2x16(color);color是一个vec2类型的双精度浮点数向量，包含两个值（0.5和0.75）。packedValue是一个32位无符号整数，值为32767（即16进制的0x7FFF）和49151（即16进制的0xBFFF）所打包成的值，即为0x7FFF 0xBFFF（即16进制的0x7FFFBFFF）。示例2vec2 color = vec2(1.0, 0.0);uint packedValue = packUnorm2x16(color);color是一个vec2类型的双精度浮点数向量，包含两个值（1.0和0.0）。packedValue是一个32位无符号整数，值为65535（即16进制的0xFFFF）和0所打包成的值，即为0xFFFF 0x0000（即16进制的0xFFFF0000）。注意事项打包后的值只包含32位整数中的最低16位和次低16位。请确保你在使用这个函数时不会出现数据溢出等问题。
----------
http://www.bimant.com/docs/glsl-es/pow/ >> (563ms) --> 
函数名称pow - 计算指定数值的幂次方函数原型float pow(float x, float y)参数x：底数，将被提升到幂次方。y：指数，指定要将底数提升到的幂次方。返回值返回指定底数和指数的幂值。描述pow函数是用来将一个指定的底数提升到一个指定的幂次方的GLSL函数。指数需要是一个浮点数，这意味着你可以提高一个指定底数的任意次幂（包括小数和负数）。注意事项如果底数和指数都为0，则结果未定义，可能会发生错误。如果指数为0，返回1.0。如果底数为0且指数为负数，则结果未定义，可能会发生错误。如果底数是负数并且指数是小数，则结果未定义，可能会发生错误。如果结果下溢，则返回0.0。如果结果上溢，则返回INFINITY。如果底数为负数且指数为整数，则结果是NaN。示例计算2的3次方。float result = pow(2.0, 3.0); // result为8.0参考资料The OpenGL Graphics System: A Specification (Version 4.6)
----------
http://www.bimant.com/docs/glsl-es/radians/ >> (493ms) --> 
GLSL radians() 函数文档简介GLSL radians() 函数是一个用于将角度转换为弧度的内置函数。 该函数接受一个表示角度的浮点数参数，并返回一个表示该角度对应的弧度值的浮点数。语法下面是 radians() 函数的语法：float radians(float degrees)参数：表示角度的浮点数值（单位：度）返回值：表示该角度对应的弧度值的浮点数值示例float angleInDegrees = 90.0;float angleInRadians = radians(angleInDegrees); // 将角度转换为弧度在上述示例中，变量 angleInDegrees 表示一个度数值，即 $90$ 度。该值将作为参数传递给 radians() 函数，该函数将此度数转换为弧度值并将其存储在变量 angleInRadians 中。注意事项radians() 函数将度数作为输入，但是在几何计算和大多数数学库中，角度通常以弧度的形式表示。因此，在进行这些计算之前，可能需要使用 radians() 函数将角度转换为弧度。由于 GLSL 不支持函数的重载，因此 radians() 函数只接受单个浮点数参数。如果要将多个角度转换为弧度，需要逐个调用该函数。radians() 函数的返回值为浮点数类型。如果需要将角度值转换为整数类型，则需要将返回值取整。例如，可以使用 GLSL 的 round() 函数将值四舍五入到最接近的整数像素。参考资料The OpenGL ES Shading Language (Version 1.00) —— The Khronos Group
----------
http://www.bimant.com/docs/glsl-es/reflect/ >> (60ms) --> 
GLSL Reflect 函数函数描述Reflect函数返回一个反射向量，它沿着一个法线向量入射一个入射向量，该法线向量必须是被归一化的向量。函数原型vec3 reflect(vec3 I, vec3 N)参数I：一个vec3类型的向量，是入射向量。N：一个vec3类型的向量，是法线向量。返回值返回一个vec3类型的向量，是反射向量。示例vec3 I = vec3(1.0, 0.0, 0.0);vec3 N = vec3(0.0, 1.0, 0.0);vec3 R = reflect(I, N); // R == vec3(-1.0, 0.0, 0.0)使用建议入射向量和法线向量必须是被归一化的向量。Reflect函数通常被用于计算镜面反射效果。当入射向量与法线向量的夹角越小时，反射向量的强度越强。可以使用dot函数来计算向量之间的点积。参考文献The Book of Shaders - ReflectGLSL Reflect function documentation
----------
http://www.bimant.com/docs/glsl-es/refract/ >> (54ms) --> 
GLSL的refract函数简介GLSL的refract函数用于计算折射向量。这个函数将一个向量与法线和折射指数相乘，得到一个新的向量，该向量表示入射向量穿过介质边界时的折射方向。语法vec3 refract(vec3 I, vec3 N, float eta)参数I : vec3类型的入射向量N :vec3类型的法向量eta : float类型的折射指数返回值vec3类型的折射向量描述这个函数首先计算入射向量与法向量之间的反射向量。然后，它使用折射指数和反射向量来计算折射向量。示例vec3 I = normalize(incoming_ray_direction);vec3 N = normalize(surface_normal);float eta = 1.3;vec3 refracted_ray_direction = refract(I, N, eta);注意事项入射向量和法向量必须被标准化。折射指数必须大于0。如果入射向量与法向量相反，则返回一个零向量。这个函数只适用于处理透明边界。
----------
http://www.bimant.com/docs/glsl-es/round/ >> (79ms) --> 
GLSL的round函数文档函数定义float round(float x)函数功能round函数返回x最接近的整数，如果跟两个整数的距离-即差的绝对值-相等，则返回跟它相邻的偶数。如果x是NAN，则结果也是NAN。参数x : 待转化的浮点数返回值返回x最接近的整数。示例float a = 1.5; // 定义一个变量a，值为1.5float b = round(a); // 使用round函数将a近似到1或2的整数值注意函数的返回值类型为float，即返回值是一个浮点数。round函数四舍五入到最接近的整数，但如果两个整数距离相等，则返回相邻的偶数。如果x是NAN，则结果也是NAN。
----------
http://www.bimant.com/docs/glsl-es/roundEven/ >> (76ms) --> 
roundEven函数文档函数描述GLSL的roundEven函数是用来将浮点数值四舍五入到最接近的偶数的函数。该函数接受一个float类型的参数，返回一个float类型的结果。该函数在GLSL 4.1及以上版本中支持，它的功能类似于C++11中的std::round函数。不同之处在于，当一个数值距离两个相邻整数的距离相等时，roundEven函数将四舍五入到最靠近偶数的整数，而std::round函数则在正负数之间交替选择。函数原型float roundEven(float x);参数说明参数名称：x参数类型：float参数描述：要四舍五入的浮点数返回值说明返回值类型：float返回值描述：四舍五入到最接近偶数的整数使用示例以下示例将一个浮点数值四舍五入到最靠近偶数的值：float a = 2.5;float b = 3.5;float c = 4.5;float d = -2.5;float e = -3.5;float f = -4.5;float round_a = roundEven(a); // 2.0float round_b = roundEven(b); // 4.0float round_c = roundEven(c); // 4.0float round_d = roundEven(d); // -2.0float round_e = roundEven(e); // -4.0float round_f = roundEven(f); // -4.0注意事项该函数不会修改参数x的值。如果参数x为NaN，则函数返回NaN。如果参数x为正零（+0.0）或负零（-0.0），则函数返回参数x的值。如果参数x的值超出了该函数能表示的数值范围，则函数的行为是未定义的。
----------
http://www.bimant.com/docs/glsl-es/sign/ >> (75ms) --> 
GLSL Sign函数文档简介GLSL的sign函数是一个三元运算符，用于判断输入数值的正负并返回相应的值。如果输入数值为正数，则返回1.0；如果为负数，则返回-1.0；如果为0，则返回0.0。float sign(float x)参数x：输入的数值，可以为标量、向量或矩阵。返回值1.0：如果输入数值为正数。-1.0：如果输入数值为负数。0.0：如果输入数值为0。示例float a = 5.0;float b = -3.0;float c = 0.0;float d = sign(a);// d = 1.0float e = sign(b);// e = -1.0float f = sign(c);// f = 0.0注意事项sign函数的输入必须为数字类型（int或float）。对于向量或矩阵作为输入参数，sign函数会逐个计算每个元素的正负，并返回一个相同维度的结果向量或矩阵。
----------
http://www.bimant.com/docs/glsl-es/sin/ >> (58ms) --> 
GLSL sin函数文档简介sin函数是GLSL编程语言中的一种内置函数，用于计算正弦值。sin函数可用于二维/三维图形的变换，如旋转等。它的参数为一个浮点数，返回值也是一个浮点数，表示所输入角度的正弦值。函数定义float sin(float angle)参数angle: 以弧度为单位的角度值。返回值float: 参数角度对应的正弦值。示例float angle = 1.2;float sinValue = sin(angle); // sinValue的值为0.932039注意事项sin函数的参数必须使用弧度制，与C++等其他编程语言不同，需要在调用函数前将角度转换为弧度。此函数返回的值为浮点数，如果需要将其转换为整数，需要使用int()或round()等函数进行转换。
----------
http://www.bimant.com/docs/glsl-es/sinh/ >> (68ms) --> 
GLSL sinh函数文档GLSL中的sinh函数用于计算给定数字的双曲正弦值。双曲正弦函数（sinh）是指数函数的双曲线形式，按照以下公式计算：sinh(x) = (e^x - e^(-x)) / 2其中，e表示自然对数的底数，即2.71828182845904523536。语法float sinh(float x)参数x：要计算双曲正弦值的数字。返回值函数返回x的双曲正弦值。示例float result = sinh(2.0); // 计算2.0的双曲正弦值注意事项如果输入x的值太大，则可能导致浮点数溢出。双曲正弦函数是单调递增函数，其导数为双曲余弦函数cosh。
----------
http://www.bimant.com/docs/glsl-es/smoothstep/ >> (504ms) --> 
smoothstep函数文档简介smoothstep函数是GLSL中用于实现平滑插值的函数之一，它可以在指定起止边界的范围内，将一个给定的值进行平滑插值。smoothstep函数在图形渲染中常常用于平滑过渡，例如在着色器计算过程中，将颜色值进行平滑渐变，从而实现渐变效果。语法smoothstep (edge0, edge1, x)edge0：float类型的起始边界edge1：float类型的终止边界，必须大于edge0x：float类型的输入值返回值smoothstep函数返回一个float类型的值，这个值的范围在[0, 1]之间，代表了输入值经过平滑插值后的结果。示例float value = 0.5;float edge0 = 0.0;float edge1 = 1.0;float smoothValue = smoothstep(edge0, edge1, value);在上面的示例中，输入值为0.5，起始边界为0.0，终止边界为1.0，根据smoothstep函数的计算规则，将这个值进行平滑插值后得到的结果为0.5，因为这个值在输入范围的中间，经过平滑插值之后也会处于0.5的位置。实现原理smoothstep函数内部实现了一个三次多项式函数，其函数表达式为：smoothstep(x) = 3x^2 - 2x^3该多项式函数在x=0.0时取值为0，在x=1.0时取值为1，在这两个点之间经过平滑插值，在x=0.5时取值为0.5。具体的平滑插值过程可以参考下图。上述函数表达式可以通过GLSL的内建函数来实现，也可以手动编写顶点着色器代码实现。在实际开发中，建议使用GLSL内建函数来实现smoothstep函数，并尽可能优化函数的执行效率。
----------
http://www.bimant.com/docs/glsl-es/sqrt/ >> (550ms) --> 
GLSL的sqrt函数文档概述sqrt函数是一个在GLSL中广泛使用的函数之一。它用于计算给定参数的平方根。语法sqrt(x)x: 需要计算平方根的浮点数返回值sqrt函数返回x的平方根。如果x是负数，则返回的值为NaN（无意义）。示例float x = 16.0;float y = sqrt(x); // 结果为4.0float z = -1.0;float w = sqrt(z); // 结果为NaN相关函数GLSL中还有许多其他的数学函数，例如sin，cos，tan等，它们也都用于对浮点数进行操作。此外，GLSL还提供了许多可以进行向量和矩阵计算的函数。注意事项sqrt函数只能用于浮点数，不能用于整数。计算的精度由硬件和GLSL实现决定。在不同的硬件和实现上，计算的精度可能有所不同。如果需要进行高精度计算，可以使用GLSL提供的其他函数，例如dFdx和dFdy。结论GLSL中的sqrt函数是计算平方根的有用工具，它能够轻松地对浮点数进行操作。在使用该函数时，请注意计算的精度，以确保正确的结果。
----------
http://www.bimant.com/docs/glsl-es/step/ >> (93ms) --> 
GLSL的step函数文档step()是一个GLSL（OpenGL Shading Language）中的内建函数，它用于返回0.0或1.0的规范化跃迁函数。语法元素类型result = step(edge, x);result：规范化阶跃值edge：阈值x：输入值。描述在step()函数中，当x小于边缘值edge时，返回0.0，否则返回1.0。换句话说，step()函数在x等于边缘值的位置处跃变，从0.0到1.0，形成一个阶跃。这个函数特别适用于在一个着色器程序中执行控制流，或创建二进制数据结构（例如纹理或扰动）。step()函数对于判断输入值处于某一区间间隔的情况非常有用。例如，要在shader程序中绘制一段长度为5的梯形，可以使用min和max计算区间，在使用step()函数将该区间处理值（即对于该值在区间内，返回1.0，在区间之外返回0.0）。扩展在GLSL中，还有一个类似的函数smoothstep()，它可以使用以下公式表示：元素类型result = smoothstep(edge0, edge1, x);result：规范化平滑跃迁值edge0：阈值0edge1：阈值1x：输入值。smoothstep()函数产生与step()类似的阶跃形式，但该函数在跃变处平滑过渡。在阈值之外，结果总是为0，在阈值之内，结果总是为1，在阈值之间，结果介于0和1之间，并且产生一个平滑的衰减效果。示例下面的代码演示了如何使用step()函数将变量x映射到0.0~1.0之间。float x = 0.5;float edge = 0.3;float result = step(edge, x);当x = 0.5且边缘值edge = 0.3时，结果为1.0，因为x大于边缘值edge，并且step()函数在x等于边缘值的位置处从0.0转变为1.0。
----------
http://www.bimant.com/docs/glsl-es/tan/ >> (485ms) --> 
GLSL tan函数文档函数原型float tan(float angle);函数描述GLSL的tan函数返回一个角度的正切值。参数必须以弧度为单位。参数angle：以弧度为单位的角度值。返回值该函数返回给定角度的正切值。示例float result = tan(0.785398); // 返回45度角的正切值，约为0.999999注意事项角度必须以弧度为单位传递给此函数。如果输入的角度为90度的倍数，无限大将作为结果返回。因此，在使用此函数之前应该检查输入值。如果需要使用角度（不是弧度），可以使用radians()将角度转换为弧度。
----------
http://www.bimant.com/docs/glsl-es/tanh/ >> (60ms) --> 
GLSL的tanh函数文档简介GLSL中的tanh函数是用来计算双曲正切函数的。双曲正切函数是指一种与正切函数相似的函数，其定义为：tanh(x) = (e^x - e^-x) / (e^x + e^-x)函数原型float tanh(float x);参数x: 要计算双曲正切函数的浮点数。返回值计算出的双曲正切函数值。使用示例// 计算双曲正切函数float result = tanh(2.0);// 使用计算结果处理顶点坐标gl_Position = vec4(result, 0.0, 0.0, 1.0);注意事项双曲正切函数的定义域为所有实数。双曲正切函数的取值范围为(-1, 1)，当函数接近正无穷或负无穷时，函数的值会趋近于+1或-1。
----------
http://www.bimant.com/docs/glsl-es/texelFetch/ >> (57ms) --> 
TexelFetch Function DocumentationFunction SignatureT texelFetch(sampler2D samp, ivec2 coord, int lod = 0)DescriptionThe texelFetch function allows explicit texture accesses and returns the texel (texture element) value from the texture unit samp at the texture coordinates coord. The texture coordinates coord are given in integer coordinates and represent the location of the texel in the texture.The type T of the returned value depends on the texture's internal format. For example, if the texture is a sampler2D with an internal format of GL_RGBA8, T would be vec4.The optional parameter lod specifies the level-of-detail to use for the texture access. If lod is not specified or set to 0, the base level-of-detail is used.ParameterssampA sampler2D texture unit to sample from.coordAn ivec2 vector specifying the integer texture coordinates of the texel to fetch.lodAn optional int value indicating the level of detail to use. Default is 0.Return ValueThe function returns the texel value at the specified coord in the format specified by the samp texture unit. The returned value has a type of T, which is dependent on the texture's internal format.Exampleuniform sampler2D tex;ivec2 coord = ivec2(2, 3);vec3 texel = texelFetch(tex, coord).rgb;The above code fetches the texel value at integer texture coordinates (2, 3) from the tex texture and assigns its RGB components to the texel variable.
----------
http://www.bimant.com/docs/glsl-es/texelFetchOffset/ >> (61ms) --> 
texelFetchOffsetvec4 texelFetchOffset(sampler2D sampler, ivec2 coord, int lod, ivec2 offset);描述texelFetchOffset函数从给定的二维纹理sampler中获取一个指定的texel，并带有一个指定的偏移量。纹理图像的坐标范围为[0, width-1]×[0, height-1]。参数sampler：指定一个纹理单元名称。coord：指定二维纹理坐标。lod：指定需要的Mip贴图级别。offset：指定一个二维偏移量，偏移向量为offset.x向x轴正方向延伸，offset.y向y轴正方向延伸。返回值返回一个vec4类型的，表示在给定的sampler中选择的texel。如果coord指定的坐标越界，则该函数返回一个初始值为0.0的vec4。版本支持OpenGL ES 2.0，OpenGL ES 3.0和OpenGL ES 3.1。参考OpenGL ES Shading Language 3.20 Specification (pdf)glTexelFetchOffset
----------
http://www.bimant.com/docs/glsl-es/texture/ >> (65ms) --> 
GLSL Texture 函数文档texture 函数用于对一个纹理进行采样，返回采样结果。它的语法如下：vec4 texture(sampler2D sampler, vec2 coord [, float bias])vec4 texture(samplerCube sampler, vec3 coord [, float bias])其中，第一个参数 sampler 表示纹理的采样器。第二个参数 coord 表示要采样的纹理坐标。第三个可选参数 bias 表示采样偏移量，如果没有提供则默认为0。texture 函数可以取样 2D 纹理和立方体纹理，取样结果将被返回为 vec4，其各个分量的值代表纹理的颜色值，范围为 0-1。使用 texture 函数的示例代码：uniform sampler2D textureSampler;varying vec2 texCoords;void main() { vec4 color = texture(textureSampler, texCoords); // 进一步处理采样结果}uniform samplerCube textureSampler;varying vec3 texCoords;void main() { vec4 color = texture(textureSampler, texCoords); // 进一步处理采样结果}参数samplersampler 表示采样器，可以是 sampler2D 或者 samplerCube。coordcoord 表示要采样的纹理坐标。如果 sampler 是一个 sampler2D，那么 coord 应该是一个二维向量 vec2。如果 sampler 是一个 samplerCube，那么 coord 应该是一个三维向量 vec3。biasbias 是一个可选参数，用于对采样结果进行偏移。如果没有提供，则默认为 0。返回值texture 函数的返回值是一个 vec4 向量，包含了取样结果的 RGBA 分量的值，分量的范围为 0-1。示例假设有一张 2D 纹理，宽度为 1024，高度为 1024，采用 RGBA 格式（每个像素有四个分量，用来表示红、绿、蓝、透明度），对应的采样器如下：uniform sampler2D textureSampler;我们可以使用 texture 来获取纹理像素（即颜色值）：vec2 uv = vec2(0.5, 0.5); // 假设要取样的点是正中心vec4 pixelColor = texture(textureSampler, uv);// pixelColor 就是纹理中点的颜色值，可以进行后续处理如果有一个立方体纹理采样器，代码如下所示：uniform samplerCube textureSampler;我们可以使用 texture 来获取采样点对应的立方体纹理像素（即颜色值）：vec3 uvw = vec3(0.5, 0.5, 0.5); // 假设要取样的点是一个立方体面的中心vec4 pixelColor = texture(textureSampler, uvw);// pixelColor 就是采样点对应的立方体纹理面的颜色值，可以进行后续处理参考资料OpenGL Shading Language - Texture Function
----------
http://www.bimant.com/docs/glsl-es/textureGrad/ >> (63ms) --> 
GLSL textureGrad函数文档函数声明vec4 textureGrad(sampler2D sam, vec2 uv, vec2 dPdx, vec2 dPdy);函数描述textureGrad函数用于根据纹理坐标和相邻像素的差异返回相邻像素的插值。相邻像素的差异由参数dPdx和dPdy确定。此函数可用于图像抽取和纹理过滤，其中dPdx和dPdy可以表示基于当前坐标x对图像进行微小变化的梯度。textureGrad函数将片段的梯度dPdx和dPdy作为参数，可以更准确地计算出图像的局部线性变化，而不是使用估计或近似值。textureGrad函数的返回值是通过纹理坐标进行插值的纹理颜色值。sampler2D类型的参数sam指定哪个纹理单元在读取纹理时使用。参数sam：纹理单元uv：纹理坐标，范围为[0,1]之间dPdx：纹理坐标x的梯度值dPdy：纹理坐标y的梯度值返回值返回纹理颜色值。如果指定的纹理无效，则返回0.示例vec2 dPdx = dFdx(v_texcoord.xy);vec2 dPdy = dFdy(v_texcoord.xy);vec4 texColor = textureGrad(u_sampler, v_texcoord.xy, dPdx, dPdy);
----------
http://www.bimant.com/docs/glsl-es/textureGradOffset/ >> (90ms) --> 
GLSL textureGradOffset 函数文档函数描述textureGradOffset 函数可以取样器采样给定纹理中的一个纹素，并使用该纹素的邻域数据来执行各向异性过滤。返回值类型：采样器的纹理数据类型参数列表：sampler：采样器类型，纹理采样的来源coord：vec类型，纹理的坐标（从左下角为 (0.0, 0.0), 右上角为 (1.0, 1.0)）ddx：vec类型，S方向上的偏导数ddy：vec类型，T方向上的偏导数offset：ivec类型，纹理的偏移量（可选参数，默认为 ivec2(0, 0)）参数说明sampler：需要进行采样的纹理类型，包括纹理图像和采样器对象sampler 可以是以下类型：• sampler1D• sampler2D• sampler3D• samplerCube• sampler1DShadow• sampler2DShadowcoord：纹理坐标的第一维是纹理图片的宽度，第二维是纹理图片的高度。纹理坐标需要将图片的左下角坐标（0.0, 0.0）转化为 (0.0, 0.0), 右上角坐标（width, height）转化为 (1.0, 1.0)coord参数可以是以下类型：• ivec2• ivec3• ivec4• vec2• vec3• vec4ddx 和 ddy：分别表示 S 方向和 T 方向上的偏导数。偏导数用于实现各向异性过滤。需要指出的是：在 OpenGL ES 2.0 和 OpenGL ES 3.0 中，偏导数取值必须由变量或常量表达式提供。ddx 和 ddy 参数可以是以下类型：• float• vec2• vec3• vec4offset（可选）：指定从指定坐标 coord 开始，向左偏移 xOffset 个像素，向上偏移 yOffset 个像素。offset 参数可以是以下类型：• ivec2示例vec4 textureData = textureGradOffset(sampler, coord, ddx, ddy, offset);参考资料Khronos OpenGL ES 3.0 Shading Language SpecificationOpenGL.org Docs GLSL Specification
----------
http://www.bimant.com/docs/glsl-es/textureLod/ >> (69ms) --> 
GLSL textureLod函数文档函数说明vec4 textureLod(sampler2D sampler, vec2 coord, float lod)vec4 textureLod(samplerCube sampler, vec3 coord, float lod)函数名称数据类型描述samplersampler2D 或 samplerCube表示采样器coordvec2 或 vec3表示采样坐标lodfloat表示使用的采样器的LOD值该函数用于基于给定的LOD值，在纹理中从给定坐标处进行采样。返回值函数将返回 vec4 值，表示采样到的颜色值。对于 alpha 只有格式，函数将返回此颜色值的 .a组件。参数samplersampler2D 或 samplerCube 类型的采样器。coord采样坐标可能为 vec2 或 vec3，具体取决于采样器类型。 对于采样器2D，coord应该是 vec2 类型，因为是从二维平面中进行采样； 对于采样器Cube，coord应该是 vec3 类型，因为是从三维立方体中进行采样。lodlod 值表示要使用的级别细节。lod值增加时，使用的纹理大小将减小，因此提高了性能和质量。 例如，一个很高的LOD值会取得较小的纹理大小并且用更少的采样。 在另一方面，低LOD值会取得较大的纹理大小并进行较多的采样。示例以下是使用 textureLod 采样器的示例：// 使用textureLod对纹理进行采样uniform sampler2D sampler;varying vec2 texCoord;void main(){ gl_FragColor = textureLod(sampler, texCoord, 2.0);}
----------
http://www.bimant.com/docs/glsl-es/textureLodOffset/ >> (476ms) --> 
GLSL函数textureLodOffset文档描述textureLodOffset函数实现了纹理取样器在一个偏移上的具有指定LOD的2D纹理采样。声明vec4 textureLodOffset(sampler2D sampler, vec2 coord, float lod, vec2 offset)参数sampler - 2D纹理采样器对象。coord - 纹理坐标。lod - 需要的LoD级别值。offset - 纹理坐标的偏移量。返回值函数返回对应采样器的纹理值。详细描述此函数使用采样器对象和提供的纹理坐标和LoD计算出所需的采样器颜色值。偏移量向量指定了从纹理坐标中心到采样位置的偏移量。该函数使用了用户指定的最高LOD级别，从而计算出所需的纹理颜色值。当被指定的LOD级别低于对象的最大LOD级别时，实现将自动成功地降低LOD来适应给定的LOD级别。此函数的计算方式如下所示：计算当前LOD级别值。根据提供的纹理坐标计算采样器对象。应用现有的过滤选项，以获得想要的过滤结果。返回过滤结果。示例uniform sampler2D mySampler;varying vec2 texCoord;void main() { vec4 texelColor = textureLodOffset(mySampler, texCoord, 0.0, vec2(0.5, 0.5)); gl_FragColor = texelColor;}该代码片段演示了如何使用textureLodOffset函数从所选采样器中获取特定LOD级别处的纹理采样器颜色值，则返回值为采样的纹理颜色值。版本函数textureLodOffset在GLSL 1.30版中首次引入。参考OpenGL中的纹理sampler2D
----------
http://www.bimant.com/docs/glsl-es/textureOffset/ >> (510ms) --> 
GLSL的textureOffset函数文档GLSL的textureOffset函数可用于从纹理图像中获取一个给定偏移量的值，如下所示：vec4 textureOffset(sampler2D sampler, vec2 coord, ivec2 offset);这个函数需要三个参数：sampler：一个sampler2D类型的纹理采样器，指定了纹理的类型和过滤方式。coord：一个vec2类型的坐标值，表示从纹理图像中采样的位置。offset：一个ivec2类型的坐标值，表示需要获取的像素的偏移量。 此偏移值应该是整数型。例如，如果offset的值为ivec2(1, 0)，则textureOffset函数将返回与coord右侧相邻的像素值。此函数将返回在采样坐标码位置偏移指定像素的值，该值将按纹理格式进行插值（如果需要的话）。 多数情况下，这个偏移因子趋向零并且对采样结果没有影响。另外，这个函数也可以用于访问纹理数组和立方体贴图。 在这种情况下，需要使用sampler2DArray或samplerCube类型采样器并使用适当的坐标系。例如，以下代码将从一个立方体贴图中获取离采样坐标码位置向右偏移1的像素的值：vec4 color = textureOffset(samplerCubeTex, coord, ivec2(1, 0));注意：textureOffset函数只在GLSL 1.30及更高版本中受支持。
----------
http://www.bimant.com/docs/glsl-es/textureProj/ >> (68ms) --> 
函数文档：textureProj该函数用于将四元素向量与纹理坐标进行项目映射，并返回所获取的纹理颜色。语法：vec4 textureProj(sampler2D sampler, vec4 coord)vec4 textureProj(sampler3D sampler, vec4 coord)参数：sampler:纹理采样器，可以是2D或3D纹理。coord:四元素向量，表示使用的纹理坐标或投影坐标。描述：该函数将四元素向量coord作为位置参数，并使用纹理采样器进行纹理采样。在进行纹理采样之前，函数会将coord向量和一个投影矩阵相乘，确保纹理坐标与投影矩阵适当地对齐。最后，该函数会返回所获取的纹理颜色作为四元素向量。返回值：返回值是一个四元素向量，代表从纹理上获取的颜色。如果sampler与coord指定的纹理坐标不在纹理范围内，则可能会返回undefined值。函数的返回值与sampler对应的纹理数据类型有关。示例：vec4 color = textureProj(sampler, vec4(texCoord, 1.0, 1.0));该代码段获取位于texCoord位置，并经过投影矩阵的影响的纹理颜色，并将其存储在四元素向量color中。参见：texturetextureLodtextureGrad附注：如果使用的是一个纹理数组，那么该函数需要使用一个额外的坐标参数来指定纹理数组中的层。对于Cubemap纹理，则需要使用一个额外的坐标参数来指定立方体面（positive_x, negative_x, positive_y, negative_y, positive_z或者negative_z）。所有的向量，在进行纹理投影之前，都会自动被除以它们的第四个分量，以保证正确的投影。储蓄纹理可以通过函数textureGather进行读取而非textureProj。
----------
http://www.bimant.com/docs/glsl-es/textureProjGrad/ >> (80ms) --> 
GLSL textureProjGrad() 函数文档函数介绍textureProjGrad() 函数根据纹理坐标、投影向量和dPdx/dPdy值从2D纹理进行采样，可以被用于任意图形对象的着色器中。它依赖于纹理对象的采样器类型，因此在使用此函数之前必须先将纹理绑定到采样器上。语法vec4 textureProjGrad(sampler2D sampler, vec3 P, vec3 dPdx, vec3 dPdy)参数sampler纹理采样器。输入必须是 2D 纹理对象。类型：sampler2D指定：必须P材质表面上一个 3D 点的纹理坐标。类型: vec3指定: 必须dPdx投影向量在P所在表面的 x 方向上的导数。类型: vec3指定: 必须dPdy投影向量在P所在表面的 y 方向上的导数。类型: vec3指定: 必须返回值返回纹理中由纹理坐标P.xy/P.w指定的2D纹理的采样值。如果纹理采样器的类型为 integer 或 unsigned integer，则将返回浮点数值转换为整数值。如果采样器被配置为使用 sRGB 纹理数据，则将线性值转换为 sRGB 值。类型：vec4示例下面是一个简单的示例，它在片段着色器中使用 textureProjGrad() 函数从 2D 纹理进行采样：#version 330in vec2 texCoord;out vec4 FragColor;uniform sampler2D textureSampler;void main(){ // 定义投影向量的导数 vec3 dPdx = dFdx(vec3(texCoord, 1)); vec3 dPdy = dFdy(vec3(texCoord, 1));// 从 2D 纹理进行采样 FragColor = textureProjGrad(textureSampler, vec3(texCoord,1), dPdx, dPdy);}在本例中，dPdx 和 dPdy 值是通过 dFdx() 和 dFdy() 函数计算出来的。这两个函数分别返回投影向量（在我们的情况下只是纹理坐标的一个矢量）相对于 x 方向和 y 方向的导数。textureProjGrad() 函数然后从采样器中获取 2D 纹理，并将纹理坐标、投影向量和导数值作为参数传递。注意事项textureProjGrad() 函数没有默认的纹理过滤器和边界环绕方式，需要在使用之前手动指定。textureProjGrad() 函数不支持纹理数组或立方体纹理。极性尺度，在计算导数时，有些驱动程序的精度可能不足以保证同样的渲染结果。
----------
http://www.bimant.com/docs/glsl-es/textureProjGradOffset/ >> (87ms) --> 
GLSL的textureProjGradOffset函数文档描述GLSL的textureProjGradOffset函数用于在进行透视校正时，根据图像坐标及纹理偏移量返回纹素值的4D向量。该函数使用有向裁剪空间坐标作为输入坐标，并返回与指定偏移量相对应的纹素值。语法vec4 textureProjGradOffset(sampler2DGradOffset sampler, vec4 P, vec4 dPdx, vec4 dPdy, float offset)参数参数描述sampler纹理单元P有向裁剪空间坐标dPdxP中x轴方向的变化率dPdyP中y轴方向的变化率offset纹理偏移量返回值四维向量，表示纹素值。错误如果纹理单元没有绑定，该函数会引发运行时错误。示例uniform sampler2DGradOffset texture;vec4 P = vec4(0.5, 0.5, 0.5, 1.0);vec4 dPdx = vec4(0.1, 0.0, 0.0, 0.0);vec4 dPdy = vec4(0.0, 0.1, 0.0, 0.0);float offset = 0.0;vec4 result = textureProjGradOffset(texture, P, dPdx, dPdy, offset);参考资料OpenGL ES Shading Language Specification
----------
http://www.bimant.com/docs/glsl-es/textureProjLod/ >> (61ms) --> 
GLSL textureProjLod函数文档函数简介vec4 textureProjLod(sampler2DShadow sampler, vec4 coord, float lod)textureProjLod函数在投影纹理中使用指定的LOD级别来对给定的纹理坐标进行采样，并返回采样结果。参数以下是textureProjLod函数的参数：sampler：类型为sampler2DShadow的投影纹理采样器。coord：类型为vec4的投影纹理坐标，其中x、y、z坐标表示投影平面的坐标，w坐标表示投影纹理的深度。lod：类型为float的指定LOD级别的值。返回值vec4类型的纹理采样结果。描述textureProjLod函数使用指定的LOD级别来进行采样。它与textureProj函数的区别在于，前者可以指定LOD级别，而后者使用自动计算的LOD级别进行采样。投影纹理是一种特殊的纹理，常用于图形学中的阴影生成。投影纹理采样器类型为sampler2DShadow，它可以用于在一个投影平面上采样阴影值。对于每个像素，投影纹理采样器会根据投影平面上的位置和深度值来计算一个采样值，这个采样值通常用于计算阴影效果。示例以下示例展示了如何在GLSL中使用textureProjLod函数：uniform sampler2DShadow shadowMap;varying vec4 shadowCoord;void main(){ float shadow = textureProjLod(shadowMap, shadowCoord, 0.5); gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0) * shadow;}在上面的示例中，我们使用了一个类型为sampler2DShadow的uniform变量shadowMap作为投影纹理，使用了一个类型为vec4的varying变量shadowCoord作为投影纹理坐标。我们将投影纹理的LOD级别设置为0.5，并对投影纹理进行采样，得到一个float类型的值shadow，然后将其与一个纯白色的vec4类型的向量相乘，得到纹理颜色，并使用这个颜色作为片元的颜色值。
----------
http://www.bimant.com/docs/glsl-es/textureProjLodOffset/ >> (70ms) --> 
GLSL textureProjLodOffset函数文档描述textureProjLodOffset()函数实现了带有LOD偏移的投影纹理采样。它返回相应投影纹理上指定坐标的采样颜色像素。在使用此函数之前，必须先将投影纹理绑定到一个纹理单元。语法GLfloat textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, vec2 offset)参数sampler：投影纹理采样器。P：需要投影的位置坐标。它是一个由4个成分组成的向量 (x, y, z, 1)，其中 (x, y, z) 是在需要进行投影的位置坐标。lod：指定使用的LOD级别。在投影采样中，LOD级别通常用于指定纹理尺寸为 （ 2^(LOD) * 2^(LOD) ) 的纹理子集的正确 Mip层次。offset：LOD值偏移的条目，以像素为单位（只在 OpenGL ES 和 OpenGL 程序中有效）。返回值textureProjLodOffset()函数的返回值是一个颜色向量。如果采样不在投影内，返回值为零向量（黑色）。示例使用 textureProjLodOffset()函数，我们可以采样投影纹理并对其应用修饰。vec4 color = textureProjLodOffset(shadowMap, projectedTexCoords, 1.0, vec2(0.0, 0.0));异常如果输入的 sampler 不存在或者没有绑定到纹理单元中，则该函数的结果是未定义的。如果 lod 值不在纹理可用的 mipmap 级别范围内，结果是未定义的。如果 offset 的值不是整数值，则 offset 中的分量将被截断到其整数部分，然后进行采样操作。如果采样不在投影面内，则该函数的结果为黑色。如果 P 的 w 分量不等于1，则结果为黑色。参考OpenGL textureProjLodOffset函数GLSL textureProjLodOffset函数
----------
http://www.bimant.com/docs/glsl-es/textureProjOffset/ >> (546ms) --> 
GLSL textureProjOffset 函数文档描述textureProjOffset 函数在纹理投影的过程中添加了一个偏移量。该函数按照给定的纹理坐标进行采样，然后将其投影到裁剪空间坐标系中，并添加偏移量以使结果更加精确。语法vec4 textureProjOffset(sampler2D sampler, vec4 coord, vec2 offset)参数sampler：采样器变量，用于对纹理进行采样。coord：vec4 类型的纹理坐标，其中前三个分量描述了纹理的空间位置，第四个分量则表示沿投影坐标系顶点到纹理视平面的距离。offset：vec2 类型的偏移量，用于添加到纹理坐标的投影中。返回值返回 vec4 类型的颜色值，表示采样得到的纹理颜色。示例使用 textureProjOffset 函数对纹理进行采样并添加一个偏移量：uniform sampler2D texSampler;varying vec4 texCoord;void main() { vec4 color = textureProjOffset(texSampler, texCoord, vec2(0.1, 0.1)); gl_FragColor = color;}注意事项coord 参数的第四个分量通常是由计算机图形学管道中的顶点着色器生成，并在传递到片段着色器中进行处理。如果传递的坐标不包含第四个分量，则其默认值为 1。offset 参数的值应该根据所使用的纹理图像进行精心选择，以确保投影图像的精度和正确性。
----------
http://www.bimant.com/docs/glsl-es/textureSize/ >> (64ms) --> 
GLSL TextureSize()函数文档简介GLSL的textureSize()函数用于返回纹理的大小。纹理的大小指的是纹理宽度和高度。该函数通常用于shader中，使shader能够通过指定的纹理单元获取纹理的大小。语法ivec2 textureSize(sampler2D sampler, int lod = 0);ivec3 textureSize(samplerCube sampler, int lod = 0);sampler: 用来获取大小的纹理单元，只能是sampler2D或samplerCube类型。lod: 存储纹理细节级别的整数值。默认值为0，表示基本级别。返回值返回一个2维或3维的整数向量，分别包含纹理的宽度和高度（如果是二维纹理），或者是纹理的宽度、高度和面数（如果是立方体纹理）。函数用ivec2或ivec3来表示返回的值，并且这些值都是正整数。示例以下是使用textureSize()函数的示例：uniform sampler2D tex;void main() { ivec2 size = textureSize(tex); // 在这里使用size.x 和 size.y 进行一些处理}uniform samplerCube tex;void main() { ivec3 size = textureSize(tex); // 在这里使用size.x、size.y 和 size.z进行一些处理}注意事项sampler2D参数必须绑定到一个有效的纹理对象上，否则该函数的行为是未定义的。立方体纹理的大小包括宽度、高度和面的数量，而不是像素总数。如果使用纹理阵列，则textureSize()函数返回的是数组中一个纹理的大小。该函数只能在片段着色器中使用，而不能在顶点着色器中使用。
----------
http://www.bimant.com/docs/glsl-es/transpose/ >> (69ms) --> 
GLSL transpose 函数文档函数说明transpose 函数返回一个矩阵的转置矩阵。函数原型mat transpose(mat m)参数说明m：一个矩阵返回值说明返回一个转置矩阵示例mat3 A = mat3(1, 2, 3, 4, 5, 6, 7, 8, 9);mat3 B = transpose(A); // 将 A 矩阵转置，得到 B 矩阵在上面的示例中，A 矩阵被定义为一个 3x3 的矩阵，然后通过调用 transpose 函数得到它的转置矩阵 B。注意事项矩阵的大小不能超过 GL_MAX_VERTEX_UNIFORM_COMPONENTS 或 GL_MAX_FRAGMENT_UNIFORM_COMPONENTS。这个值是OpenGL实现的它所支持的uniform数据的最大数量。矩阵中的元素必须是浮点数类型。综上所述，transpose 函数是用来计算矩阵转置的，它的参数是一个矩阵，返回值是矩阵的转置矩阵。
----------
http://www.bimant.com/docs/glsl-es/trunc/ >> (60ms) --> 
trunc 函数函数原型： float trunc(float x)描述trunc 函数返回参数 x 的整数部分，即将小数部分截断的整数。参数x：需要截断小数部分的数值。返回值截去小数部分后的整数值。注意如果 x 是正数，trunc 函数将向 0 取整，即向最接近 0 的整数方向取整；如果 x 是负数，则截断后的整数值是小于原值的，等于向 0 取整后再加上 1。示例trunc(-4.2); // 输出 -4.0trunc(3.9);// 输出 3.0trunc(0.0);// 输出 0.0与其他函数的关系trunc 函数与 floor 函数类似，都是将小数部分截断，但 floor 函数始终向下取整，即小于等于原值的最大整数；而 trunc 函数则向 0 取整，即始终向最接近 0 的整数方向取整。trunc 函数与 round 函数也有些类似，都可以将小数部分截断，但 round 函数则是四舍五入取整，即小数点后第一位小于 5 直接舍去，大于等于 5 则进位。
----------
http://www.bimant.com/docs/glsl-es/uintBitsToFloat/ >> (52ms) --> 
函数名：uintBitsToFloat函数描述：将一个32位无符号整数的比特位解释为单精度浮点数。参数：unsigned int bits：32位无符号整数，代表要转换的浮点数的二进制形式。返回值：float：32位单精度浮点数示例：uintBitsToFloat(0x3F800000u); //返回1.0uintBitsToFloat(0x40490FDBu); //返回3.1415926注意事项：输入的值必须为32位无符号整数；此函数不进行有效性检查。如果输入的二进制序列无法正确解析为单精度浮点数，则输出结果不确定；此函数不能用于解释任意位整数作为浮点数的表示方式，只能接受 32 位无符号整数表示的二进制形式；
----------
http://www.bimant.com/docs/glsl-es/unpackHalf2x16/ >> (0ms) -->

----------
http://www.bimant.com/docs/glsl-es/unpackSnorm2x16/ >> (112ms) --> 
GLSL unpackSnorm2x16函数文档函数描述unpackSnorm2x16函数将两个16位带符号整数打包为存储在32位返回值中的两个浮点值。函数原型vec2 unpackSnorm2x16(int16 val)参数val: 待解包的带符号整数。返回值vec2类型，包含两个浮点值，表示解包后的值。细节val参数被解释为带符号规范化整数。 解包算法如下：将前16位上的带符号整数值进行反转，变为在[-1, 1]之间的浮点数。将后16位上的带符号整数值进行反转，变为在[-1, 1]之间的浮点数。返回包含这两个浮点数的vec2结构。由于该算法使用浮点数转换，因此，结果可能包含舍入误差。示例int16 val = 4000;vec2 result = unpackSnorm2x16(val); // result为vec2(-0.717315, 0.696098)参考原始提案：ARB_shader_glslOpenGL 3.3中的文档：glslangSpec.3.30.pdf
----------
http://www.bimant.com/docs/glsl-es/unpackUnorm2x16/ >> (104ms) --> 
函数说明文档 - unpackUnorm2x16(GLuint value)函数说明函数 unpackUnorm2x16 的作用是将一个使用 2 个无符号整数表示的 16 位浮点数打包成单个 32 位浮点数。这个函数主要用于将纹理中的二维模板数据按照一定格式，转化为一个二维采样坐标。函数参数参数名类型描述valueGLuint一个使用 2 个无符号整数表示的 16 位浮点数返回值返回一个使用单个 32 位浮点数表示的 16 位浮点数。实现方法此函数的实现方式为：取 value 的低 16 位作为无符号整数 u，将其转化为浮点数 f，返回 f/65535.0。示例vec2 data = vec2(0.123, 0.456);uvec2 packedData = packUnorm2x16(data);uint uintData = packedData.x << 16 | packedData.y;float unpackedData = unpackUnorm2x16(uintData);注意事项该函数适用于解压从 packUnorm2x16 函数压缩得到的数据。该函数不适用于普通的 16 位浮点数解压。